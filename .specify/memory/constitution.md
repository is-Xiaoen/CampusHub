# CampusHub Constitution

## 项目概述

CampusHub 是一个集社交、活动发布与即时通讯（IM）于一体的高并发微服务平台。旨在解决用户"发起活动难、沟通成本高"的痛点，实现从"报名"到"沟通"的无缝闭环。

**技术栈**:
- 开发语言: Golang 1.24
- 微服务框架: Go-Zero (gRPC + HTTP)
- 消息中间件: Redis/RedPanda + Watermill
- 存储层: MySQL (持久化), Redis (缓存/会话)
- 服务拆分: User, Activity, IM 独立服务

---

## 核心原则

### I. 微服务独立性原则

**服务自治**: 每个微服务（User, Activity, IM）必须独立部署、独立扩展、独立演进。
- 服务间通过 gRPC 进行同步调用，通过消息队列进行异步通信
- 禁止跨服务直接访问数据库，必须通过 RPC 接口
- 每个服务拥有独立的数据库 schema，避免数据库层面的耦合
- 服务边界清晰，职责单一，避免"大泥球"架构

**依赖管理**:
- 使用 Go Modules 管理依赖，go.mod 文件必须提交到版本控制
- 共享代码通过内部 package 或独立 library 管理
- 避免循环依赖，服务依赖关系必须是有向无环图（DAG）

### II. API 优先设计

**契约先行**: API 定义先于实现，使用 Protocol Buffers 定义服务契约。
- 所有 RPC 服务必须先定义 .proto 文件，经过评审后再实现
- HTTP API 使用 Go-Zero 的 .api 文件定义，支持自动生成文档
- API 变更必须遵循语义化版本规范，向后兼容

**RESTful 规范**:
- HTTP API 遵循 RESTful 设计原则
- 使用标准 HTTP 方法：GET (查询), POST (创建), PUT (更新), DELETE (删除)
- 统一响应格式：`{"code": 0, "msg": "success", "data": {...}}`
- 错误码统一管理，避免魔法数字

**gRPC 规范**:
- 服务间调用优先使用 gRPC，性能敏感场景必须使用
- 使用 protobuf 进行序列化，确保跨语言兼容性
- 实现健康检查接口，支持服务发现和负载均衡

### III. 测试驱动开发 (NON-NEGOTIABLE)

**测试优先**: 所有核心业务逻辑必须先编写测试，后实现功能。
- 单元测试覆盖率要求 ≥ 70%，核心业务逻辑 ≥ 90%
- 使用 `go test` 和 `testify` 框架编写测试
- 每个 PR 必须包含相应的测试用例，CI 自动运行测试

**测试分层**:
- **单元测试**: 测试单个函数/方法，使用 mock 隔离依赖
- **集成测试**: 测试服务间交互，使用 testcontainers 启动依赖服务
- **E2E 测试**: 测试完整业务流程，使用 Apifox 进行接口测试

**测试规范**:
- 测试文件命名：`xxx_test.go`
- 测试函数命名：`TestXxx` 或 `BenchmarkXxx`
- 使用 table-driven tests 提高测试可维护性
- Mock 使用 `gomock` 或 `testify/mock`

### IV. 可观测性优先

**日志规范**:
- 使用结构化日志（JSON 格式），便于日志聚合和分析
- 日志级别：DEBUG, INFO, WARN, ERROR, FATAL
- 关键操作必须记录日志：用户操作、RPC 调用、数据库操作、错误信息
- 日志中必须包含 trace_id，用于分布式追踪

**监控指标**:
- 使用 Prometheus 采集指标：QPS, 延迟, 错误率, 资源使用率
- 关键业务指标：活动发布数、报名数、消息发送数
- 设置告警规则：错误率 > 1%, P99 延迟 > 500ms

**链路追踪**:
- 使用 OpenTelemetry 进行分布式追踪
- 每个请求必须携带 trace_id，跨服务传递
- 关键路径必须添加 span，便于性能分析

### V. 性能与安全并重

**性能要求**:
- API 响应时间 P99 < 500ms, P95 < 200ms
- 数据库查询必须添加索引，避免全表扫描
- 使用 Redis 缓存热点数据，缓存命中率 > 80%
- 高并发场景使用消息队列削峰填谷

**安全规范**:
- 所有外部输入必须进行参数校验，防止注入攻击
- 敏感数据（密码、token）必须加密存储
- API 必须进行身份认证和权限校验（JWT）
- 使用 HTTPS 加密传输，禁止明文传输敏感信息
- 定期进行安全审计和漏洞扫描

---

## 代码规范

### Go 编码规范

**命名规范**:
- 包名：小写，简短，有意义（如 `user`, `activity`, `im`）
- 文件名：小写，下划线分隔（如 `user_service.go`）
- 变量/函数：驼峰命名（如 `getUserInfo`, `activityList`）
- 常量：大写，下划线分隔（如 `MAX_RETRY_COUNT`）
- 接口：以 `er` 结尾（如 `Reader`, `Writer`）

**代码风格**:
- 使用 `gofmt` 和 `goimports` 格式化代码
- 使用 `golangci-lint` 进行静态代码检查
- 每个函数不超过 50 行，复杂逻辑拆分为多个函数
- 避免深层嵌套（最多 3 层），使用 early return

**错误处理**:
- 使用 `errors.Wrap` 包装错误，保留错误上下文
- 不要忽略错误，必须显式处理或向上传递
- 自定义错误类型，便于错误分类和处理
- 使用 `defer` 确保资源释放（如数据库连接、文件句柄）

### Go-Zero 框架规范

**项目结构**:
```
service/
├── api/           # HTTP API 定义和实现
│   ├── desc/      # .api 文件
│   ├── handler/   # HTTP handler
│   └── logic/     # 业务逻辑
├── rpc/           # gRPC 服务定义和实现
│   ├── pb/        # .proto 文件和生成代码
│   ├── internal/  # 内部实现
│   └── client/    # RPC 客户端
├── model/         # 数据模型和数据库操作
├── config/        # 配置文件
└── etc/           # 配置文件（yaml）
```

**配置管理**:
- 使用 YAML 格式配置文件
- 敏感配置（数据库密码、API key）使用环境变量
- 支持多环境配置：dev, test, prod
- 配置热更新，避免重启服务

**中间件使用**:
- 统一使用 Go-Zero 中间件：日志、追踪、限流、熔断
- 自定义中间件放在 `middleware/` 目录
- 中间件顺序：日志 → 追踪 → 认证 → 限流 → 业务逻辑

---

## 数据库与缓存规范

### MySQL 规范

**表设计**:
- 使用 InnoDB 引擎，支持事务和外键
- 主键使用自增 ID 或雪花算法生成的分布式 ID
- 必须字段：`id`, `created_at`, `updated_at`, `deleted_at`（软删除）
- 字段类型选择：VARCHAR(255), TEXT, INT, BIGINT, DATETIME
- 避免使用 BLOB 存储大文件，使用对象存储（OSS）

**索引规范**:
- 主键索引：每张表必须有主键
- 唯一索引：唯一性约束字段（如 username, email）
- 普通索引：查询条件字段（如 user_id, activity_id）
- 联合索引：多字段查询（遵循最左前缀原则）
- 避免过多索引，影响写入性能

**查询优化**:
- 避免 SELECT *，只查询需要的字段
- 使用 LIMIT 分页，避免一次查询大量数据
- 复杂查询使用 EXPLAIN 分析执行计划
- 避免在 WHERE 条件中使用函数，导致索引失效

### Redis 规范

**缓存策略**:
- 热点数据缓存：用户信息、活动详情
- 缓存过期时间：根据数据更新频率设置（5min ~ 1hour）
- 缓存更新策略：Cache Aside Pattern（先更新数据库，再删除缓存）
- 缓存穿透：使用布隆过滤器或缓存空值
- 缓存雪崩：设置随机过期时间，避免同时失效

**Key 命名规范**:
- 格式：`{service}:{module}:{id}`
- 示例：`user:info:123`, `activity:detail:456`
- 使用冒号分隔，便于管理和监控

**数据结构选择**:
- String：简单键值对（如用户 token）
- Hash：对象存储（如用户信息）
- List：消息队列、时间线
- Set：去重集合（如活动参与者）
- ZSet：排行榜、延迟队列

---

## 消息队列规范

### Watermill 使用规范

**消息发布**:
- 消息格式：JSON，包含 `event_type`, `payload`, `timestamp`, `trace_id`
- 消息幂等性：使用唯一 ID，避免重复消费
- 消息持久化：重要消息必须持久化到 Redis/RedPanda

**消息订阅**:
- 消费者组：同一消费者组内的消费者负载均衡
- 错误重试：失败消息自动重试，最多 3 次
- 死信队列：重试失败的消息进入死信队列，人工处理

**事件驱动场景**:
- 活动报名成功 → 创建群聊
- 用户注册成功 → 发送欢迎消息
- 活动状态变更 → 通知参与者

---

## 开发工作流程

### 分支管理

- **main**: 主分支，保护分支，只能通过 PR 合并
- **develop**: 开发分支，日常开发在此分支
- **feature/xxx**: 功能分支，从 develop 拉取，开发完成后合并回 develop
- **hotfix/xxx**: 紧急修复分支，从 main 拉取，修复后合并回 main 和 develop

### 提交规范

**Commit Message 格式**:
```
<type>(<scope>): <subject>

<body>

<footer>
```

**Type 类型**:
- `feat`: 新功能
- `fix`: 修复 bug
- `docs`: 文档更新
- `style`: 代码格式调整
- `refactor`: 重构
- `test`: 测试相关
- `chore`: 构建/工具链相关

**示例**:
```
feat(activity): 添加活动报名功能

- 实现活动报名 API
- 添加报名人数限制
- 自动创建群聊

Closes #123
```

### Code Review

**PR 要求**:
- PR 标题清晰，描述变更内容
- PR 描述包含：变更原因、实现方案、测试结果
- 代码变更 < 500 行，大型变更拆分为多个 PR
- 必须通过 CI 检查：测试、lint、构建

**Review 检查项**:
- 代码是否符合规范
- 是否有充分的测试覆盖
- 是否有性能问题或安全隐患
- 是否有更好的实现方案

### 发布流程

1. **测试环境部署**: 合并到 develop 分支，自动部署到测试环境
2. **集成测试**: 运行 Apifox 自动化测试，确保接口可用
3. **预发布环境**: 合并到 release 分支，部署到预发布环境
4. **生产环境发布**: 合并到 main 分支，打 tag，部署到生产环境
5. **监控告警**: 发布后监控关键指标，及时发现问题

---

## 治理规则

### 规范执行

- 本 Constitution 是项目开发的最高准则，所有开发活动必须遵守
- 所有 PR 必须经过 Code Review，确保符合规范
- CI/CD 流程自动检查代码质量、测试覆盖率、安全漏洞
- 定期进行代码审计和技术债务清理

### 规范修订

- Constitution 修订需要团队讨论和投票通过
- 修订内容必须文档化，包含修订原因和影响范围
- 修订后需要通知全体成员，并更新相关文档

### 例外处理

- 特殊情况下可以申请例外，但必须说明理由并获得批准
- 例外情况必须记录在案，并在后续版本中修复
- 技术债务必须及时偿还，避免累积

---

**Version**: 1.0.0 | **Ratified**: 2026-01-30 | **Last Amended**: 2026-01-30
