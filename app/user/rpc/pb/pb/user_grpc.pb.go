// ============================================================================
// User 模块 Proto 定义文件
// ============================================================================
//
// 文件说明：
//   定义 User 模块的内部 gRPC 服务接口，供【其他微服务】调用。
//   不对外暴露，不经过 Gateway。
//
// 包含服务：
//   - CreditService: 信用分服务
//   - VerifyService: 学生认证服务
//
// 调用方：
//   - Activity RPC（报名/发布权限校验）
//   - MQ Consumer（信用分变更）
//   - User API（查询信用信息）
//
// 字段编号规划：
//   - 1-30: 基础字段
//   - 31-50: 扩展字段
//   警告：字段编号一旦发布使用后不可更改或复用！
//
// 生成命令：
//   cd app/user/rpc
//   goctl rpc protoc user.proto --go_out=./pb --go-grpc_out=./pb --zrpc_out=. -style go_zero
//
// ============================================================================

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.9.0
// source: user.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	CreditService_GetCreditInfo_FullMethodName  = "/user.CreditService/GetCreditInfo"
	CreditService_GetCreditLogs_FullMethodName  = "/user.CreditService/GetCreditLogs"
	CreditService_CanParticipate_FullMethodName = "/user.CreditService/CanParticipate"
	CreditService_CanPublish_FullMethodName     = "/user.CreditService/CanPublish"
	CreditService_InitCredit_FullMethodName     = "/user.CreditService/InitCredit"
	CreditService_UpdateScore_FullMethodName    = "/user.CreditService/UpdateScore"
)

// CreditServiceClient is the client API for CreditService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CreditServiceClient interface {
	// GetCreditInfo 获取用户信用信息
	// 调用方: User API（个人中心-信用信息页面）
	// 业务逻辑: 返回用户当前的信用分、等级、特权信息
	GetCreditInfo(ctx context.Context, in *GetCreditInfoReq, opts ...grpc.CallOption) (*GetCreditInfoResp, error)
	// GetCreditLogs 获取信用变更记录列表
	// 调用方: User API（信用分明细页面）
	// 业务逻辑: 分页查询用户的信用变更记录，支持按类型和时间筛选
	GetCreditLogs(ctx context.Context, in *GetCreditLogsReq, opts ...grpc.CallOption) (*GetCreditLogsResp, error)
	// CanParticipate 校验是否允许报名
	// 调用方: Activity服务（报名模块）
	// 业务逻辑:
	//   - score < 60: 黑名单，禁止报名
	//   - 60 <= score < 70: 风险用户，每日限报名1次
	//   - score >= 70: 正常报名
	CanParticipate(ctx context.Context, in *CanParticipateReq, opts ...grpc.CallOption) (*CanParticipateResp, error)
	// CanPublish 校验是否允许发布活动
	// 调用方: Activity服务（发布模块）
	// 业务逻辑:
	//   - score >= 90: 允许发布（Lv3优秀用户、Lv4社区之星）
	//   - score < 90: 禁止发布
	CanPublish(ctx context.Context, in *CanPublishReq, opts ...grpc.CallOption) (*CanPublishResp, error)
	// InitCredit 初始化信用分
	// 调用方: User服务（注册流程）
	// 业务逻辑: 用户注册成功后初始化信用分为100分（Lv4社区之星）
	InitCredit(ctx context.Context, in *InitCreditReq, opts ...grpc.CallOption) (*InitCreditResp, error)
	// UpdateScore 变更信用分
	// 调用方: MQ Consumer（内部系统）
	// 业务逻辑: 签到、爽约、活动结束等事件触发信用分变更
	// 幂等保证: 通过 source_id 实现幂等
	UpdateScore(ctx context.Context, in *UpdateScoreReq, opts ...grpc.CallOption) (*UpdateScoreResp, error)
}

type creditServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCreditServiceClient(cc grpc.ClientConnInterface) CreditServiceClient {
	return &creditServiceClient{cc}
}

func (c *creditServiceClient) GetCreditInfo(ctx context.Context, in *GetCreditInfoReq, opts ...grpc.CallOption) (*GetCreditInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCreditInfoResp)
	err := c.cc.Invoke(ctx, CreditService_GetCreditInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *creditServiceClient) GetCreditLogs(ctx context.Context, in *GetCreditLogsReq, opts ...grpc.CallOption) (*GetCreditLogsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCreditLogsResp)
	err := c.cc.Invoke(ctx, CreditService_GetCreditLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *creditServiceClient) CanParticipate(ctx context.Context, in *CanParticipateReq, opts ...grpc.CallOption) (*CanParticipateResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CanParticipateResp)
	err := c.cc.Invoke(ctx, CreditService_CanParticipate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *creditServiceClient) CanPublish(ctx context.Context, in *CanPublishReq, opts ...grpc.CallOption) (*CanPublishResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CanPublishResp)
	err := c.cc.Invoke(ctx, CreditService_CanPublish_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *creditServiceClient) InitCredit(ctx context.Context, in *InitCreditReq, opts ...grpc.CallOption) (*InitCreditResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InitCreditResp)
	err := c.cc.Invoke(ctx, CreditService_InitCredit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *creditServiceClient) UpdateScore(ctx context.Context, in *UpdateScoreReq, opts ...grpc.CallOption) (*UpdateScoreResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateScoreResp)
	err := c.cc.Invoke(ctx, CreditService_UpdateScore_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CreditServiceServer is the server API for CreditService service.
// All implementations must embed UnimplementedCreditServiceServer
// for forward compatibility.
type CreditServiceServer interface {
	// GetCreditInfo 获取用户信用信息
	// 调用方: User API（个人中心-信用信息页面）
	// 业务逻辑: 返回用户当前的信用分、等级、特权信息
	GetCreditInfo(context.Context, *GetCreditInfoReq) (*GetCreditInfoResp, error)
	// GetCreditLogs 获取信用变更记录列表
	// 调用方: User API（信用分明细页面）
	// 业务逻辑: 分页查询用户的信用变更记录，支持按类型和时间筛选
	GetCreditLogs(context.Context, *GetCreditLogsReq) (*GetCreditLogsResp, error)
	// CanParticipate 校验是否允许报名
	// 调用方: Activity服务（报名模块）
	// 业务逻辑:
	//   - score < 60: 黑名单，禁止报名
	//   - 60 <= score < 70: 风险用户，每日限报名1次
	//   - score >= 70: 正常报名
	CanParticipate(context.Context, *CanParticipateReq) (*CanParticipateResp, error)
	// CanPublish 校验是否允许发布活动
	// 调用方: Activity服务（发布模块）
	// 业务逻辑:
	//   - score >= 90: 允许发布（Lv3优秀用户、Lv4社区之星）
	//   - score < 90: 禁止发布
	CanPublish(context.Context, *CanPublishReq) (*CanPublishResp, error)
	// InitCredit 初始化信用分
	// 调用方: User服务（注册流程）
	// 业务逻辑: 用户注册成功后初始化信用分为100分（Lv4社区之星）
	InitCredit(context.Context, *InitCreditReq) (*InitCreditResp, error)
	// UpdateScore 变更信用分
	// 调用方: MQ Consumer（内部系统）
	// 业务逻辑: 签到、爽约、活动结束等事件触发信用分变更
	// 幂等保证: 通过 source_id 实现幂等
	UpdateScore(context.Context, *UpdateScoreReq) (*UpdateScoreResp, error)
	mustEmbedUnimplementedCreditServiceServer()
}

// UnimplementedCreditServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCreditServiceServer struct{}

func (UnimplementedCreditServiceServer) GetCreditInfo(context.Context, *GetCreditInfoReq) (*GetCreditInfoResp, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCreditInfo not implemented")
}
func (UnimplementedCreditServiceServer) GetCreditLogs(context.Context, *GetCreditLogsReq) (*GetCreditLogsResp, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCreditLogs not implemented")
}
func (UnimplementedCreditServiceServer) CanParticipate(context.Context, *CanParticipateReq) (*CanParticipateResp, error) {
	return nil, status.Error(codes.Unimplemented, "method CanParticipate not implemented")
}
func (UnimplementedCreditServiceServer) CanPublish(context.Context, *CanPublishReq) (*CanPublishResp, error) {
	return nil, status.Error(codes.Unimplemented, "method CanPublish not implemented")
}
func (UnimplementedCreditServiceServer) InitCredit(context.Context, *InitCreditReq) (*InitCreditResp, error) {
	return nil, status.Error(codes.Unimplemented, "method InitCredit not implemented")
}
func (UnimplementedCreditServiceServer) UpdateScore(context.Context, *UpdateScoreReq) (*UpdateScoreResp, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateScore not implemented")
}
func (UnimplementedCreditServiceServer) mustEmbedUnimplementedCreditServiceServer() {}
func (UnimplementedCreditServiceServer) testEmbeddedByValue()                       {}

// UnsafeCreditServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CreditServiceServer will
// result in compilation errors.
type UnsafeCreditServiceServer interface {
	mustEmbedUnimplementedCreditServiceServer()
}

func RegisterCreditServiceServer(s grpc.ServiceRegistrar, srv CreditServiceServer) {
	// If the following call panics, it indicates UnimplementedCreditServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CreditService_ServiceDesc, srv)
}

func _CreditService_GetCreditInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCreditInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreditServiceServer).GetCreditInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CreditService_GetCreditInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreditServiceServer).GetCreditInfo(ctx, req.(*GetCreditInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CreditService_GetCreditLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCreditLogsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreditServiceServer).GetCreditLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CreditService_GetCreditLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreditServiceServer).GetCreditLogs(ctx, req.(*GetCreditLogsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CreditService_CanParticipate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CanParticipateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreditServiceServer).CanParticipate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CreditService_CanParticipate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreditServiceServer).CanParticipate(ctx, req.(*CanParticipateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CreditService_CanPublish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CanPublishReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreditServiceServer).CanPublish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CreditService_CanPublish_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreditServiceServer).CanPublish(ctx, req.(*CanPublishReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CreditService_InitCredit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitCreditReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreditServiceServer).InitCredit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CreditService_InitCredit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreditServiceServer).InitCredit(ctx, req.(*InitCreditReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CreditService_UpdateScore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateScoreReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreditServiceServer).UpdateScore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CreditService_UpdateScore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreditServiceServer).UpdateScore(ctx, req.(*UpdateScoreReq))
	}
	return interceptor(ctx, in, info, handler)
}

// CreditService_ServiceDesc is the grpc.ServiceDesc for CreditService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CreditService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.CreditService",
	HandlerType: (*CreditServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCreditInfo",
			Handler:    _CreditService_GetCreditInfo_Handler,
		},
		{
			MethodName: "GetCreditLogs",
			Handler:    _CreditService_GetCreditLogs_Handler,
		},
		{
			MethodName: "CanParticipate",
			Handler:    _CreditService_CanParticipate_Handler,
		},
		{
			MethodName: "CanPublish",
			Handler:    _CreditService_CanPublish_Handler,
		},
		{
			MethodName: "InitCredit",
			Handler:    _CreditService_InitCredit_Handler,
		},
		{
			MethodName: "UpdateScore",
			Handler:    _CreditService_UpdateScore_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}

const (
	VerifyService_GetVerifyCurrent_FullMethodName     = "/user.VerifyService/GetVerifyCurrent"
	VerifyService_GetVerifyInfo_FullMethodName        = "/user.VerifyService/GetVerifyInfo"
	VerifyService_IsVerified_FullMethodName           = "/user.VerifyService/IsVerified"
	VerifyService_ApplyStudentVerify_FullMethodName   = "/user.VerifyService/ApplyStudentVerify"
	VerifyService_ConfirmStudentVerify_FullMethodName = "/user.VerifyService/ConfirmStudentVerify"
	VerifyService_CancelStudentVerify_FullMethodName  = "/user.VerifyService/CancelStudentVerify"
	VerifyService_UpdateVerifyStatus_FullMethodName   = "/user.VerifyService/UpdateVerifyStatus"
	VerifyService_ProcessOcrVerify_FullMethodName     = "/user.VerifyService/ProcessOcrVerify"
)

// VerifyServiceClient is the client API for VerifyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VerifyServiceClient interface {
	// GetVerifyCurrent 获取当前认证进度
	// 调用方: User API（进入认证页面时调用）
	// 业务逻辑: 返回用户当前的认证状态、可执行的操作、OCR识别数据等
	GetVerifyCurrent(ctx context.Context, in *GetVerifyCurrentReq, opts ...grpc.CallOption) (*GetVerifyCurrentResp, error)
	// GetVerifyInfo 获取已通过的认证信息
	// 调用方: User API（个人中心-认证信息页面）
	// 业务逻辑: 仅返回已通过认证用户的脱敏信息
	GetVerifyInfo(ctx context.Context, in *GetVerifyInfoReq, opts ...grpc.CallOption) (*GetVerifyInfoResp, error)
	// IsVerified 查询用户是否已完成学生认证
	// 调用方: Activity服务（报名/发布活动前校验）
	// 场景: 需要确认用户学生身份时调用
	IsVerified(ctx context.Context, in *IsVerifiedReq, opts ...grpc.CallOption) (*IsVerifiedResp, error)
	// ApplyStudentVerify 提交学生认证申请
	// 调用方: User API
	// 业务逻辑:
	//  1. 限流检查（20s内≤2次）
	//  2. 唯一性校验（学校+学号）
	//  3. 状态机校验
	//  4. 创建记录并触发OCR
	ApplyStudentVerify(ctx context.Context, in *ApplyStudentVerifyReq, opts ...grpc.CallOption) (*ApplyStudentVerifyResp, error)
	// ConfirmStudentVerify 用户确认/修改认证信息
	// 调用方: User API
	// 业务逻辑:
	//   - 确认无误 -> 状态改为4（已通过）
	//   - 修改信息 -> 状态改为3（人工审核）
	ConfirmStudentVerify(ctx context.Context, in *ConfirmStudentVerifyReq, opts ...grpc.CallOption) (*ConfirmStudentVerifyResp, error)
	// CancelStudentVerify 取消认证申请
	// 调用方: User API
	// 业务逻辑: 状态改为7（已取消）
	CancelStudentVerify(ctx context.Context, in *CancelStudentVerifyReq, opts ...grpc.CallOption) (*CancelStudentVerifyResp, error)
	// UpdateVerifyStatus 更新认证状态
	// 调用方: MQ Consumer（OCR回调、人工审核结果）、定时任务（超时处理）
	// 业务逻辑: 处理认证流程中的状态流转
	UpdateVerifyStatus(ctx context.Context, in *UpdateVerifyStatusReq, opts ...grpc.CallOption) (*UpdateVerifyStatusResp, error)
	// ProcessOcrVerify 处理 OCR 识别（供统一 MQ Consumer 调用）
	// 调用方: app/mq 消费者（消费 verify:events 事件）
	// 业务逻辑:
	//  1. 查询认证记录，校验状态（必须为 OcrPending）
	//  2. 检查是否超时（>10min 直接标记超时）
	//  3. 调用 OCR 识别（主提供商+备用故障转移）
	//  4. 成功 → 更新为 WaitConfirm + 回填OCR数据
	//  5. 失败 → 更新为 OcrFailed
	ProcessOcrVerify(ctx context.Context, in *ProcessOcrVerifyReq, opts ...grpc.CallOption) (*ProcessOcrVerifyResp, error)
}

type verifyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVerifyServiceClient(cc grpc.ClientConnInterface) VerifyServiceClient {
	return &verifyServiceClient{cc}
}

func (c *verifyServiceClient) GetVerifyCurrent(ctx context.Context, in *GetVerifyCurrentReq, opts ...grpc.CallOption) (*GetVerifyCurrentResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetVerifyCurrentResp)
	err := c.cc.Invoke(ctx, VerifyService_GetVerifyCurrent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifyServiceClient) GetVerifyInfo(ctx context.Context, in *GetVerifyInfoReq, opts ...grpc.CallOption) (*GetVerifyInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetVerifyInfoResp)
	err := c.cc.Invoke(ctx, VerifyService_GetVerifyInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifyServiceClient) IsVerified(ctx context.Context, in *IsVerifiedReq, opts ...grpc.CallOption) (*IsVerifiedResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsVerifiedResp)
	err := c.cc.Invoke(ctx, VerifyService_IsVerified_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifyServiceClient) ApplyStudentVerify(ctx context.Context, in *ApplyStudentVerifyReq, opts ...grpc.CallOption) (*ApplyStudentVerifyResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApplyStudentVerifyResp)
	err := c.cc.Invoke(ctx, VerifyService_ApplyStudentVerify_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifyServiceClient) ConfirmStudentVerify(ctx context.Context, in *ConfirmStudentVerifyReq, opts ...grpc.CallOption) (*ConfirmStudentVerifyResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfirmStudentVerifyResp)
	err := c.cc.Invoke(ctx, VerifyService_ConfirmStudentVerify_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifyServiceClient) CancelStudentVerify(ctx context.Context, in *CancelStudentVerifyReq, opts ...grpc.CallOption) (*CancelStudentVerifyResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelStudentVerifyResp)
	err := c.cc.Invoke(ctx, VerifyService_CancelStudentVerify_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifyServiceClient) UpdateVerifyStatus(ctx context.Context, in *UpdateVerifyStatusReq, opts ...grpc.CallOption) (*UpdateVerifyStatusResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateVerifyStatusResp)
	err := c.cc.Invoke(ctx, VerifyService_UpdateVerifyStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifyServiceClient) ProcessOcrVerify(ctx context.Context, in *ProcessOcrVerifyReq, opts ...grpc.CallOption) (*ProcessOcrVerifyResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessOcrVerifyResp)
	err := c.cc.Invoke(ctx, VerifyService_ProcessOcrVerify_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VerifyServiceServer is the server API for VerifyService service.
// All implementations must embed UnimplementedVerifyServiceServer
// for forward compatibility.
type VerifyServiceServer interface {
	// GetVerifyCurrent 获取当前认证进度
	// 调用方: User API（进入认证页面时调用）
	// 业务逻辑: 返回用户当前的认证状态、可执行的操作、OCR识别数据等
	GetVerifyCurrent(context.Context, *GetVerifyCurrentReq) (*GetVerifyCurrentResp, error)
	// GetVerifyInfo 获取已通过的认证信息
	// 调用方: User API（个人中心-认证信息页面）
	// 业务逻辑: 仅返回已通过认证用户的脱敏信息
	GetVerifyInfo(context.Context, *GetVerifyInfoReq) (*GetVerifyInfoResp, error)
	// IsVerified 查询用户是否已完成学生认证
	// 调用方: Activity服务（报名/发布活动前校验）
	// 场景: 需要确认用户学生身份时调用
	IsVerified(context.Context, *IsVerifiedReq) (*IsVerifiedResp, error)
	// ApplyStudentVerify 提交学生认证申请
	// 调用方: User API
	// 业务逻辑:
	//  1. 限流检查（20s内≤2次）
	//  2. 唯一性校验（学校+学号）
	//  3. 状态机校验
	//  4. 创建记录并触发OCR
	ApplyStudentVerify(context.Context, *ApplyStudentVerifyReq) (*ApplyStudentVerifyResp, error)
	// ConfirmStudentVerify 用户确认/修改认证信息
	// 调用方: User API
	// 业务逻辑:
	//   - 确认无误 -> 状态改为4（已通过）
	//   - 修改信息 -> 状态改为3（人工审核）
	ConfirmStudentVerify(context.Context, *ConfirmStudentVerifyReq) (*ConfirmStudentVerifyResp, error)
	// CancelStudentVerify 取消认证申请
	// 调用方: User API
	// 业务逻辑: 状态改为7（已取消）
	CancelStudentVerify(context.Context, *CancelStudentVerifyReq) (*CancelStudentVerifyResp, error)
	// UpdateVerifyStatus 更新认证状态
	// 调用方: MQ Consumer（OCR回调、人工审核结果）、定时任务（超时处理）
	// 业务逻辑: 处理认证流程中的状态流转
	UpdateVerifyStatus(context.Context, *UpdateVerifyStatusReq) (*UpdateVerifyStatusResp, error)
	// ProcessOcrVerify 处理 OCR 识别（供统一 MQ Consumer 调用）
	// 调用方: app/mq 消费者（消费 verify:events 事件）
	// 业务逻辑:
	//  1. 查询认证记录，校验状态（必须为 OcrPending）
	//  2. 检查是否超时（>10min 直接标记超时）
	//  3. 调用 OCR 识别（主提供商+备用故障转移）
	//  4. 成功 → 更新为 WaitConfirm + 回填OCR数据
	//  5. 失败 → 更新为 OcrFailed
	ProcessOcrVerify(context.Context, *ProcessOcrVerifyReq) (*ProcessOcrVerifyResp, error)
	mustEmbedUnimplementedVerifyServiceServer()
}

// UnimplementedVerifyServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVerifyServiceServer struct{}

func (UnimplementedVerifyServiceServer) GetVerifyCurrent(context.Context, *GetVerifyCurrentReq) (*GetVerifyCurrentResp, error) {
	return nil, status.Error(codes.Unimplemented, "method GetVerifyCurrent not implemented")
}
func (UnimplementedVerifyServiceServer) GetVerifyInfo(context.Context, *GetVerifyInfoReq) (*GetVerifyInfoResp, error) {
	return nil, status.Error(codes.Unimplemented, "method GetVerifyInfo not implemented")
}
func (UnimplementedVerifyServiceServer) IsVerified(context.Context, *IsVerifiedReq) (*IsVerifiedResp, error) {
	return nil, status.Error(codes.Unimplemented, "method IsVerified not implemented")
}
func (UnimplementedVerifyServiceServer) ApplyStudentVerify(context.Context, *ApplyStudentVerifyReq) (*ApplyStudentVerifyResp, error) {
	return nil, status.Error(codes.Unimplemented, "method ApplyStudentVerify not implemented")
}
func (UnimplementedVerifyServiceServer) ConfirmStudentVerify(context.Context, *ConfirmStudentVerifyReq) (*ConfirmStudentVerifyResp, error) {
	return nil, status.Error(codes.Unimplemented, "method ConfirmStudentVerify not implemented")
}
func (UnimplementedVerifyServiceServer) CancelStudentVerify(context.Context, *CancelStudentVerifyReq) (*CancelStudentVerifyResp, error) {
	return nil, status.Error(codes.Unimplemented, "method CancelStudentVerify not implemented")
}
func (UnimplementedVerifyServiceServer) UpdateVerifyStatus(context.Context, *UpdateVerifyStatusReq) (*UpdateVerifyStatusResp, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateVerifyStatus not implemented")
}
func (UnimplementedVerifyServiceServer) ProcessOcrVerify(context.Context, *ProcessOcrVerifyReq) (*ProcessOcrVerifyResp, error) {
	return nil, status.Error(codes.Unimplemented, "method ProcessOcrVerify not implemented")
}
func (UnimplementedVerifyServiceServer) mustEmbedUnimplementedVerifyServiceServer() {}
func (UnimplementedVerifyServiceServer) testEmbeddedByValue()                       {}

// UnsafeVerifyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VerifyServiceServer will
// result in compilation errors.
type UnsafeVerifyServiceServer interface {
	mustEmbedUnimplementedVerifyServiceServer()
}

func RegisterVerifyServiceServer(s grpc.ServiceRegistrar, srv VerifyServiceServer) {
	// If the following call panics, it indicates UnimplementedVerifyServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VerifyService_ServiceDesc, srv)
}

func _VerifyService_GetVerifyCurrent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVerifyCurrentReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifyServiceServer).GetVerifyCurrent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VerifyService_GetVerifyCurrent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifyServiceServer).GetVerifyCurrent(ctx, req.(*GetVerifyCurrentReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifyService_GetVerifyInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVerifyInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifyServiceServer).GetVerifyInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VerifyService_GetVerifyInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifyServiceServer).GetVerifyInfo(ctx, req.(*GetVerifyInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifyService_IsVerified_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsVerifiedReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifyServiceServer).IsVerified(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VerifyService_IsVerified_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifyServiceServer).IsVerified(ctx, req.(*IsVerifiedReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifyService_ApplyStudentVerify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyStudentVerifyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifyServiceServer).ApplyStudentVerify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VerifyService_ApplyStudentVerify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifyServiceServer).ApplyStudentVerify(ctx, req.(*ApplyStudentVerifyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifyService_ConfirmStudentVerify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfirmStudentVerifyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifyServiceServer).ConfirmStudentVerify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VerifyService_ConfirmStudentVerify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifyServiceServer).ConfirmStudentVerify(ctx, req.(*ConfirmStudentVerifyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifyService_CancelStudentVerify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelStudentVerifyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifyServiceServer).CancelStudentVerify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VerifyService_CancelStudentVerify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifyServiceServer).CancelStudentVerify(ctx, req.(*CancelStudentVerifyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifyService_UpdateVerifyStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateVerifyStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifyServiceServer).UpdateVerifyStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VerifyService_UpdateVerifyStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifyServiceServer).UpdateVerifyStatus(ctx, req.(*UpdateVerifyStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifyService_ProcessOcrVerify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessOcrVerifyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifyServiceServer).ProcessOcrVerify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VerifyService_ProcessOcrVerify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifyServiceServer).ProcessOcrVerify(ctx, req.(*ProcessOcrVerifyReq))
	}
	return interceptor(ctx, in, info, handler)
}

// VerifyService_ServiceDesc is the grpc.ServiceDesc for VerifyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VerifyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.VerifyService",
	HandlerType: (*VerifyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVerifyCurrent",
			Handler:    _VerifyService_GetVerifyCurrent_Handler,
		},
		{
			MethodName: "GetVerifyInfo",
			Handler:    _VerifyService_GetVerifyInfo_Handler,
		},
		{
			MethodName: "IsVerified",
			Handler:    _VerifyService_IsVerified_Handler,
		},
		{
			MethodName: "ApplyStudentVerify",
			Handler:    _VerifyService_ApplyStudentVerify_Handler,
		},
		{
			MethodName: "ConfirmStudentVerify",
			Handler:    _VerifyService_ConfirmStudentVerify_Handler,
		},
		{
			MethodName: "CancelStudentVerify",
			Handler:    _VerifyService_CancelStudentVerify_Handler,
		},
		{
			MethodName: "UpdateVerifyStatus",
			Handler:    _VerifyService_UpdateVerifyStatus_Handler,
		},
		{
			MethodName: "ProcessOcrVerify",
			Handler:    _VerifyService_ProcessOcrVerify_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}

const (
	TagService_GetAllTags_FullMethodName         = "/user.TagService/GetAllTags"
	TagService_GetTagsByIds_FullMethodName       = "/user.TagService/GetTagsByIds"
	TagService_GetUserTags_FullMethodName        = "/user.TagService/GetUserTags"
	TagService_UpdateUserTag_FullMethodName      = "/user.TagService/UpdateUserTag"
	TagService_GetAllInterestTags_FullMethodName = "/user.TagService/GetAllInterestTags"
)

// TagServiceClient is the client API for TagService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TagServiceClient interface {
	GetAllTags(ctx context.Context, in *GetAllTagsReq, opts ...grpc.CallOption) (*GetAllTagsResp, error)
	GetTagsByIds(ctx context.Context, in *GetTagsByIdsReq, opts ...grpc.CallOption) (*GetTagsByIdsResp, error)
	GetUserTags(ctx context.Context, in *GetUserTagsReq, opts ...grpc.CallOption) (*GetUserTagsResponse, error)
	// 修改用户兴趣
	UpdateUserTag(ctx context.Context, in *UpdateUserTagReq, opts ...grpc.CallOption) (*UpdateUserTagResponse, error)
	// 获取所有的兴趣标签
	GetAllInterestTags(ctx context.Context, in *GetAllInterestTagsReq, opts ...grpc.CallOption) (*GetAllInterestTagsResp, error)
}

type tagServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTagServiceClient(cc grpc.ClientConnInterface) TagServiceClient {
	return &tagServiceClient{cc}
}

func (c *tagServiceClient) GetAllTags(ctx context.Context, in *GetAllTagsReq, opts ...grpc.CallOption) (*GetAllTagsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllTagsResp)
	err := c.cc.Invoke(ctx, TagService_GetAllTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagServiceClient) GetTagsByIds(ctx context.Context, in *GetTagsByIdsReq, opts ...grpc.CallOption) (*GetTagsByIdsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTagsByIdsResp)
	err := c.cc.Invoke(ctx, TagService_GetTagsByIds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagServiceClient) GetUserTags(ctx context.Context, in *GetUserTagsReq, opts ...grpc.CallOption) (*GetUserTagsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserTagsResponse)
	err := c.cc.Invoke(ctx, TagService_GetUserTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagServiceClient) UpdateUserTag(ctx context.Context, in *UpdateUserTagReq, opts ...grpc.CallOption) (*UpdateUserTagResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateUserTagResponse)
	err := c.cc.Invoke(ctx, TagService_UpdateUserTag_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagServiceClient) GetAllInterestTags(ctx context.Context, in *GetAllInterestTagsReq, opts ...grpc.CallOption) (*GetAllInterestTagsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllInterestTagsResp)
	err := c.cc.Invoke(ctx, TagService_GetAllInterestTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TagServiceServer is the server API for TagService service.
// All implementations must embed UnimplementedTagServiceServer
// for forward compatibility.
type TagServiceServer interface {
	GetAllTags(context.Context, *GetAllTagsReq) (*GetAllTagsResp, error)
	GetTagsByIds(context.Context, *GetTagsByIdsReq) (*GetTagsByIdsResp, error)
	GetUserTags(context.Context, *GetUserTagsReq) (*GetUserTagsResponse, error)
	// 修改用户兴趣
	UpdateUserTag(context.Context, *UpdateUserTagReq) (*UpdateUserTagResponse, error)
	// 获取所有的兴趣标签
	GetAllInterestTags(context.Context, *GetAllInterestTagsReq) (*GetAllInterestTagsResp, error)
	mustEmbedUnimplementedTagServiceServer()
}

// UnimplementedTagServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTagServiceServer struct{}

func (UnimplementedTagServiceServer) GetAllTags(context.Context, *GetAllTagsReq) (*GetAllTagsResp, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAllTags not implemented")
}
func (UnimplementedTagServiceServer) GetTagsByIds(context.Context, *GetTagsByIdsReq) (*GetTagsByIdsResp, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTagsByIds not implemented")
}
func (UnimplementedTagServiceServer) GetUserTags(context.Context, *GetUserTagsReq) (*GetUserTagsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUserTags not implemented")
}
func (UnimplementedTagServiceServer) UpdateUserTag(context.Context, *UpdateUserTagReq) (*UpdateUserTagResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateUserTag not implemented")
}
func (UnimplementedTagServiceServer) GetAllInterestTags(context.Context, *GetAllInterestTagsReq) (*GetAllInterestTagsResp, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAllInterestTags not implemented")
}
func (UnimplementedTagServiceServer) mustEmbedUnimplementedTagServiceServer() {}
func (UnimplementedTagServiceServer) testEmbeddedByValue()                    {}

// UnsafeTagServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TagServiceServer will
// result in compilation errors.
type UnsafeTagServiceServer interface {
	mustEmbedUnimplementedTagServiceServer()
}

func RegisterTagServiceServer(s grpc.ServiceRegistrar, srv TagServiceServer) {
	// If the following call panics, it indicates UnimplementedTagServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TagService_ServiceDesc, srv)
}

func _TagService_GetAllTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllTagsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).GetAllTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_GetAllTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).GetAllTags(ctx, req.(*GetAllTagsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagService_GetTagsByIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTagsByIdsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).GetTagsByIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_GetTagsByIds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).GetTagsByIds(ctx, req.(*GetTagsByIdsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagService_GetUserTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserTagsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).GetUserTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_GetUserTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).GetUserTags(ctx, req.(*GetUserTagsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagService_UpdateUserTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserTagReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).UpdateUserTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_UpdateUserTag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).UpdateUserTag(ctx, req.(*UpdateUserTagReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagService_GetAllInterestTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllInterestTagsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).GetAllInterestTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_GetAllInterestTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).GetAllInterestTags(ctx, req.(*GetAllInterestTagsReq))
	}
	return interceptor(ctx, in, info, handler)
}

// TagService_ServiceDesc is the grpc.ServiceDesc for TagService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TagService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.TagService",
	HandlerType: (*TagServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllTags",
			Handler:    _TagService_GetAllTags_Handler,
		},
		{
			MethodName: "GetTagsByIds",
			Handler:    _TagService_GetTagsByIds_Handler,
		},
		{
			MethodName: "GetUserTags",
			Handler:    _TagService_GetUserTags_Handler,
		},
		{
			MethodName: "UpdateUserTag",
			Handler:    _TagService_UpdateUserTag_Handler,
		},
		{
			MethodName: "GetAllInterestTags",
			Handler:    _TagService_GetAllInterestTags_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}

const (
	UserBasicService_GetGroupUser_FullMethodName    = "/user.UserBasicService/GetGroupUser"
	UserBasicService_Login_FullMethodName           = "/user.UserBasicService/Login"
	UserBasicService_Logout_FullMethodName          = "/user.UserBasicService/Logout"
	UserBasicService_Register_FullMethodName        = "/user.UserBasicService/Register"
	UserBasicService_RefreshToken_FullMethodName    = "/user.UserBasicService/RefreshToken"
	UserBasicService_GetUserInfo_FullMethodName     = "/user.UserBasicService/GetUserInfo"
	UserBasicService_UpdatePassword_FullMethodName  = "/user.UserBasicService/UpdatePassword"
	UserBasicService_UpdateUserInfo_FullMethodName  = "/user.UserBasicService/UpdateUserInfo"
	UserBasicService_DeleteUser_FullMethodName      = "/user.UserBasicService/DeleteUser"
	UserBasicService_ForgetPassword_FullMethodName  = "/user.UserBasicService/ForgetPassword"
	UserBasicService_CheckUserExists_FullMethodName = "/user.UserBasicService/CheckUserExists"
	UserBasicService_GetUserHome_FullMethodName     = "/user.UserBasicService/GetUserHome"
)

// UserBasicServiceClient is the client API for UserBasicService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserBasicServiceClient interface {
	// 批量获取群聊用户的信息
	GetGroupUser(ctx context.Context, in *GetGroupUserReq, opts ...grpc.CallOption) (*GetGroupUserResponse, error)
	// 用户登录
	Login(ctx context.Context, in *LoginReq, opts ...grpc.CallOption) (*LoginResponse, error)
	// 用户登出
	Logout(ctx context.Context, in *LogoutReq, opts ...grpc.CallOption) (*LogoutResponse, error)
	// 用户注册
	Register(ctx context.Context, in *RegisterReq, opts ...grpc.CallOption) (*RegisterResponse, error)
	// 刷新短token
	RefreshToken(ctx context.Context, in *RefreshReq, opts ...grpc.CallOption) (*RefreshResponse, error)
	// 获取用户的信息
	GetUserInfo(ctx context.Context, in *GetUserInfoReq, opts ...grpc.CallOption) (*GetUserInfoResponse, error)
	// 修改用户密码
	UpdatePassword(ctx context.Context, in *UpdatePasswordReq, opts ...grpc.CallOption) (*UpdatePasswordResponse, error)
	// 修改用户信息
	UpdateUserInfo(ctx context.Context, in *UpdateUserInfoReq, opts ...grpc.CallOption) (*UpdateUserInfoResponse, error)
	// 用户注销自己
	DeleteUser(ctx context.Context, in *DeleteUserReq, opts ...grpc.CallOption) (*DeleteUserResponse, error)
	// 用户忘记密码
	ForgetPassword(ctx context.Context, in *ForgetPasswordReq, opts ...grpc.CallOption) (*ForgetPasswordResponse, error)
	// 检查用户是否存在（通过邮箱）
	CheckUserExists(ctx context.Context, in *CheckUserExistsReq, opts ...grpc.CallOption) (*CheckUserExistsResponse, error)
	// 获取用户主页信息
	GetUserHome(ctx context.Context, in *GetUserHomeReq, opts ...grpc.CallOption) (*GetUserHomeResp, error)
}

type userBasicServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserBasicServiceClient(cc grpc.ClientConnInterface) UserBasicServiceClient {
	return &userBasicServiceClient{cc}
}

func (c *userBasicServiceClient) GetGroupUser(ctx context.Context, in *GetGroupUserReq, opts ...grpc.CallOption) (*GetGroupUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGroupUserResponse)
	err := c.cc.Invoke(ctx, UserBasicService_GetGroupUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userBasicServiceClient) Login(ctx context.Context, in *LoginReq, opts ...grpc.CallOption) (*LoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, UserBasicService_Login_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userBasicServiceClient) Logout(ctx context.Context, in *LogoutReq, opts ...grpc.CallOption) (*LogoutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LogoutResponse)
	err := c.cc.Invoke(ctx, UserBasicService_Logout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userBasicServiceClient) Register(ctx context.Context, in *RegisterReq, opts ...grpc.CallOption) (*RegisterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterResponse)
	err := c.cc.Invoke(ctx, UserBasicService_Register_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userBasicServiceClient) RefreshToken(ctx context.Context, in *RefreshReq, opts ...grpc.CallOption) (*RefreshResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RefreshResponse)
	err := c.cc.Invoke(ctx, UserBasicService_RefreshToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userBasicServiceClient) GetUserInfo(ctx context.Context, in *GetUserInfoReq, opts ...grpc.CallOption) (*GetUserInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserInfoResponse)
	err := c.cc.Invoke(ctx, UserBasicService_GetUserInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userBasicServiceClient) UpdatePassword(ctx context.Context, in *UpdatePasswordReq, opts ...grpc.CallOption) (*UpdatePasswordResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdatePasswordResponse)
	err := c.cc.Invoke(ctx, UserBasicService_UpdatePassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userBasicServiceClient) UpdateUserInfo(ctx context.Context, in *UpdateUserInfoReq, opts ...grpc.CallOption) (*UpdateUserInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateUserInfoResponse)
	err := c.cc.Invoke(ctx, UserBasicService_UpdateUserInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userBasicServiceClient) DeleteUser(ctx context.Context, in *DeleteUserReq, opts ...grpc.CallOption) (*DeleteUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteUserResponse)
	err := c.cc.Invoke(ctx, UserBasicService_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userBasicServiceClient) ForgetPassword(ctx context.Context, in *ForgetPasswordReq, opts ...grpc.CallOption) (*ForgetPasswordResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ForgetPasswordResponse)
	err := c.cc.Invoke(ctx, UserBasicService_ForgetPassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userBasicServiceClient) CheckUserExists(ctx context.Context, in *CheckUserExistsReq, opts ...grpc.CallOption) (*CheckUserExistsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckUserExistsResponse)
	err := c.cc.Invoke(ctx, UserBasicService_CheckUserExists_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userBasicServiceClient) GetUserHome(ctx context.Context, in *GetUserHomeReq, opts ...grpc.CallOption) (*GetUserHomeResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserHomeResp)
	err := c.cc.Invoke(ctx, UserBasicService_GetUserHome_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserBasicServiceServer is the server API for UserBasicService service.
// All implementations must embed UnimplementedUserBasicServiceServer
// for forward compatibility.
type UserBasicServiceServer interface {
	// 批量获取群聊用户的信息
	GetGroupUser(context.Context, *GetGroupUserReq) (*GetGroupUserResponse, error)
	// 用户登录
	Login(context.Context, *LoginReq) (*LoginResponse, error)
	// 用户登出
	Logout(context.Context, *LogoutReq) (*LogoutResponse, error)
	// 用户注册
	Register(context.Context, *RegisterReq) (*RegisterResponse, error)
	// 刷新短token
	RefreshToken(context.Context, *RefreshReq) (*RefreshResponse, error)
	// 获取用户的信息
	GetUserInfo(context.Context, *GetUserInfoReq) (*GetUserInfoResponse, error)
	// 修改用户密码
	UpdatePassword(context.Context, *UpdatePasswordReq) (*UpdatePasswordResponse, error)
	// 修改用户信息
	UpdateUserInfo(context.Context, *UpdateUserInfoReq) (*UpdateUserInfoResponse, error)
	// 用户注销自己
	DeleteUser(context.Context, *DeleteUserReq) (*DeleteUserResponse, error)
	// 用户忘记密码
	ForgetPassword(context.Context, *ForgetPasswordReq) (*ForgetPasswordResponse, error)
	// 检查用户是否存在（通过邮箱）
	CheckUserExists(context.Context, *CheckUserExistsReq) (*CheckUserExistsResponse, error)
	// 获取用户主页信息
	GetUserHome(context.Context, *GetUserHomeReq) (*GetUserHomeResp, error)
	mustEmbedUnimplementedUserBasicServiceServer()
}

// UnimplementedUserBasicServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserBasicServiceServer struct{}

func (UnimplementedUserBasicServiceServer) GetGroupUser(context.Context, *GetGroupUserReq) (*GetGroupUserResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetGroupUser not implemented")
}
func (UnimplementedUserBasicServiceServer) Login(context.Context, *LoginReq) (*LoginResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedUserBasicServiceServer) Logout(context.Context, *LogoutReq) (*LogoutResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Logout not implemented")
}
func (UnimplementedUserBasicServiceServer) Register(context.Context, *RegisterReq) (*RegisterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedUserBasicServiceServer) RefreshToken(context.Context, *RefreshReq) (*RefreshResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RefreshToken not implemented")
}
func (UnimplementedUserBasicServiceServer) GetUserInfo(context.Context, *GetUserInfoReq) (*GetUserInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUserInfo not implemented")
}
func (UnimplementedUserBasicServiceServer) UpdatePassword(context.Context, *UpdatePasswordReq) (*UpdatePasswordResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdatePassword not implemented")
}
func (UnimplementedUserBasicServiceServer) UpdateUserInfo(context.Context, *UpdateUserInfoReq) (*UpdateUserInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateUserInfo not implemented")
}
func (UnimplementedUserBasicServiceServer) DeleteUser(context.Context, *DeleteUserReq) (*DeleteUserResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUserBasicServiceServer) ForgetPassword(context.Context, *ForgetPasswordReq) (*ForgetPasswordResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ForgetPassword not implemented")
}
func (UnimplementedUserBasicServiceServer) CheckUserExists(context.Context, *CheckUserExistsReq) (*CheckUserExistsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckUserExists not implemented")
}
func (UnimplementedUserBasicServiceServer) GetUserHome(context.Context, *GetUserHomeReq) (*GetUserHomeResp, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUserHome not implemented")
}
func (UnimplementedUserBasicServiceServer) mustEmbedUnimplementedUserBasicServiceServer() {}
func (UnimplementedUserBasicServiceServer) testEmbeddedByValue()                          {}

// UnsafeUserBasicServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserBasicServiceServer will
// result in compilation errors.
type UnsafeUserBasicServiceServer interface {
	mustEmbedUnimplementedUserBasicServiceServer()
}

func RegisterUserBasicServiceServer(s grpc.ServiceRegistrar, srv UserBasicServiceServer) {
	// If the following call panics, it indicates UnimplementedUserBasicServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserBasicService_ServiceDesc, srv)
}

func _UserBasicService_GetGroupUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGroupUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserBasicServiceServer).GetGroupUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserBasicService_GetGroupUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserBasicServiceServer).GetGroupUser(ctx, req.(*GetGroupUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserBasicService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserBasicServiceServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserBasicService_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserBasicServiceServer).Login(ctx, req.(*LoginReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserBasicService_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserBasicServiceServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserBasicService_Logout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserBasicServiceServer).Logout(ctx, req.(*LogoutReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserBasicService_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserBasicServiceServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserBasicService_Register_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserBasicServiceServer).Register(ctx, req.(*RegisterReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserBasicService_RefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserBasicServiceServer).RefreshToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserBasicService_RefreshToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserBasicServiceServer).RefreshToken(ctx, req.(*RefreshReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserBasicService_GetUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserBasicServiceServer).GetUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserBasicService_GetUserInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserBasicServiceServer).GetUserInfo(ctx, req.(*GetUserInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserBasicService_UpdatePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePasswordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserBasicServiceServer).UpdatePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserBasicService_UpdatePassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserBasicServiceServer).UpdatePassword(ctx, req.(*UpdatePasswordReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserBasicService_UpdateUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserBasicServiceServer).UpdateUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserBasicService_UpdateUserInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserBasicServiceServer).UpdateUserInfo(ctx, req.(*UpdateUserInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserBasicService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserBasicServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserBasicService_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserBasicServiceServer).DeleteUser(ctx, req.(*DeleteUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserBasicService_ForgetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForgetPasswordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserBasicServiceServer).ForgetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserBasicService_ForgetPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserBasicServiceServer).ForgetPassword(ctx, req.(*ForgetPasswordReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserBasicService_CheckUserExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckUserExistsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserBasicServiceServer).CheckUserExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserBasicService_CheckUserExists_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserBasicServiceServer).CheckUserExists(ctx, req.(*CheckUserExistsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserBasicService_GetUserHome_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserHomeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserBasicServiceServer).GetUserHome(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserBasicService_GetUserHome_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserBasicServiceServer).GetUserHome(ctx, req.(*GetUserHomeReq))
	}
	return interceptor(ctx, in, info, handler)
}

// UserBasicService_ServiceDesc is the grpc.ServiceDesc for UserBasicService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserBasicService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.UserBasicService",
	HandlerType: (*UserBasicServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetGroupUser",
			Handler:    _UserBasicService_GetGroupUser_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _UserBasicService_Login_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _UserBasicService_Logout_Handler,
		},
		{
			MethodName: "Register",
			Handler:    _UserBasicService_Register_Handler,
		},
		{
			MethodName: "RefreshToken",
			Handler:    _UserBasicService_RefreshToken_Handler,
		},
		{
			MethodName: "GetUserInfo",
			Handler:    _UserBasicService_GetUserInfo_Handler,
		},
		{
			MethodName: "UpdatePassword",
			Handler:    _UserBasicService_UpdatePassword_Handler,
		},
		{
			MethodName: "UpdateUserInfo",
			Handler:    _UserBasicService_UpdateUserInfo_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _UserBasicService_DeleteUser_Handler,
		},
		{
			MethodName: "ForgetPassword",
			Handler:    _UserBasicService_ForgetPassword_Handler,
		},
		{
			MethodName: "CheckUserExists",
			Handler:    _UserBasicService_CheckUserExists_Handler,
		},
		{
			MethodName: "GetUserHome",
			Handler:    _UserBasicService_GetUserHome_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}

const (
	TagBranchService_IncrTagUsageCount_FullMethodName = "/user.TagBranchService/IncrTagUsageCount"
	TagBranchService_DecrTagUsageCount_FullMethodName = "/user.TagBranchService/DecrTagUsageCount"
)

// TagBranchServiceClient is the client API for TagBranchService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TagBranchServiceClient interface {
	// IncrTagUsageCount 增加标签使用计数（正向操作）
	IncrTagUsageCount(ctx context.Context, in *TagUsageCountReq, opts ...grpc.CallOption) (*TagUsageCountResp, error)
	// DecrTagUsageCount 减少标签使用计数（补偿操作）
	DecrTagUsageCount(ctx context.Context, in *TagUsageCountReq, opts ...grpc.CallOption) (*TagUsageCountResp, error)
}

type tagBranchServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTagBranchServiceClient(cc grpc.ClientConnInterface) TagBranchServiceClient {
	return &tagBranchServiceClient{cc}
}

func (c *tagBranchServiceClient) IncrTagUsageCount(ctx context.Context, in *TagUsageCountReq, opts ...grpc.CallOption) (*TagUsageCountResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TagUsageCountResp)
	err := c.cc.Invoke(ctx, TagBranchService_IncrTagUsageCount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagBranchServiceClient) DecrTagUsageCount(ctx context.Context, in *TagUsageCountReq, opts ...grpc.CallOption) (*TagUsageCountResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TagUsageCountResp)
	err := c.cc.Invoke(ctx, TagBranchService_DecrTagUsageCount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TagBranchServiceServer is the server API for TagBranchService service.
// All implementations must embed UnimplementedTagBranchServiceServer
// for forward compatibility.
type TagBranchServiceServer interface {
	// IncrTagUsageCount 增加标签使用计数（正向操作）
	IncrTagUsageCount(context.Context, *TagUsageCountReq) (*TagUsageCountResp, error)
	// DecrTagUsageCount 减少标签使用计数（补偿操作）
	DecrTagUsageCount(context.Context, *TagUsageCountReq) (*TagUsageCountResp, error)
	mustEmbedUnimplementedTagBranchServiceServer()
}

// UnimplementedTagBranchServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTagBranchServiceServer struct{}

func (UnimplementedTagBranchServiceServer) IncrTagUsageCount(context.Context, *TagUsageCountReq) (*TagUsageCountResp, error) {
	return nil, status.Error(codes.Unimplemented, "method IncrTagUsageCount not implemented")
}
func (UnimplementedTagBranchServiceServer) DecrTagUsageCount(context.Context, *TagUsageCountReq) (*TagUsageCountResp, error) {
	return nil, status.Error(codes.Unimplemented, "method DecrTagUsageCount not implemented")
}
func (UnimplementedTagBranchServiceServer) mustEmbedUnimplementedTagBranchServiceServer() {}
func (UnimplementedTagBranchServiceServer) testEmbeddedByValue()                          {}

// UnsafeTagBranchServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TagBranchServiceServer will
// result in compilation errors.
type UnsafeTagBranchServiceServer interface {
	mustEmbedUnimplementedTagBranchServiceServer()
}

func RegisterTagBranchServiceServer(s grpc.ServiceRegistrar, srv TagBranchServiceServer) {
	// If the following call panics, it indicates UnimplementedTagBranchServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TagBranchService_ServiceDesc, srv)
}

func _TagBranchService_IncrTagUsageCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagUsageCountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagBranchServiceServer).IncrTagUsageCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagBranchService_IncrTagUsageCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagBranchServiceServer).IncrTagUsageCount(ctx, req.(*TagUsageCountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagBranchService_DecrTagUsageCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagUsageCountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagBranchServiceServer).DecrTagUsageCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagBranchService_DecrTagUsageCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagBranchServiceServer).DecrTagUsageCount(ctx, req.(*TagUsageCountReq))
	}
	return interceptor(ctx, in, info, handler)
}

// TagBranchService_ServiceDesc is the grpc.ServiceDesc for TagBranchService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TagBranchService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.TagBranchService",
	HandlerType: (*TagBranchServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "IncrTagUsageCount",
			Handler:    _TagBranchService_IncrTagUsageCount_Handler,
		},
		{
			MethodName: "DecrTagUsageCount",
			Handler:    _TagBranchService_DecrTagUsageCount_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}

const (
	CaptchaService_GetCaptchaConfig_FullMethodName = "/user.CaptchaService/GetCaptchaConfig"
	CaptchaService_CheckCaptcha_FullMethodName     = "/user.CaptchaService/CheckCaptcha"
)

// CaptchaServiceClient is the client API for CaptchaService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 验证码服务
type CaptchaServiceClient interface {
	GetCaptchaConfig(ctx context.Context, in *GetCaptchaConfigReq, opts ...grpc.CallOption) (*GetCaptchaConfigResponse, error)
	CheckCaptcha(ctx context.Context, in *CheckCaptchaReq, opts ...grpc.CallOption) (*CheckCaptchaResponse, error)
}

type captchaServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCaptchaServiceClient(cc grpc.ClientConnInterface) CaptchaServiceClient {
	return &captchaServiceClient{cc}
}

func (c *captchaServiceClient) GetCaptchaConfig(ctx context.Context, in *GetCaptchaConfigReq, opts ...grpc.CallOption) (*GetCaptchaConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCaptchaConfigResponse)
	err := c.cc.Invoke(ctx, CaptchaService_GetCaptchaConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *captchaServiceClient) CheckCaptcha(ctx context.Context, in *CheckCaptchaReq, opts ...grpc.CallOption) (*CheckCaptchaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckCaptchaResponse)
	err := c.cc.Invoke(ctx, CaptchaService_CheckCaptcha_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CaptchaServiceServer is the server API for CaptchaService service.
// All implementations must embed UnimplementedCaptchaServiceServer
// for forward compatibility.
//
// 验证码服务
type CaptchaServiceServer interface {
	GetCaptchaConfig(context.Context, *GetCaptchaConfigReq) (*GetCaptchaConfigResponse, error)
	CheckCaptcha(context.Context, *CheckCaptchaReq) (*CheckCaptchaResponse, error)
	mustEmbedUnimplementedCaptchaServiceServer()
}

// UnimplementedCaptchaServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCaptchaServiceServer struct{}

func (UnimplementedCaptchaServiceServer) GetCaptchaConfig(context.Context, *GetCaptchaConfigReq) (*GetCaptchaConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCaptchaConfig not implemented")
}
func (UnimplementedCaptchaServiceServer) CheckCaptcha(context.Context, *CheckCaptchaReq) (*CheckCaptchaResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckCaptcha not implemented")
}
func (UnimplementedCaptchaServiceServer) mustEmbedUnimplementedCaptchaServiceServer() {}
func (UnimplementedCaptchaServiceServer) testEmbeddedByValue()                        {}

// UnsafeCaptchaServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CaptchaServiceServer will
// result in compilation errors.
type UnsafeCaptchaServiceServer interface {
	mustEmbedUnimplementedCaptchaServiceServer()
}

func RegisterCaptchaServiceServer(s grpc.ServiceRegistrar, srv CaptchaServiceServer) {
	// If the following call panics, it indicates UnimplementedCaptchaServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CaptchaService_ServiceDesc, srv)
}

func _CaptchaService_GetCaptchaConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCaptchaConfigReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CaptchaServiceServer).GetCaptchaConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CaptchaService_GetCaptchaConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CaptchaServiceServer).GetCaptchaConfig(ctx, req.(*GetCaptchaConfigReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CaptchaService_CheckCaptcha_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckCaptchaReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CaptchaServiceServer).CheckCaptcha(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CaptchaService_CheckCaptcha_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CaptchaServiceServer).CheckCaptcha(ctx, req.(*CheckCaptchaReq))
	}
	return interceptor(ctx, in, info, handler)
}

// CaptchaService_ServiceDesc is the grpc.ServiceDesc for CaptchaService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CaptchaService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.CaptchaService",
	HandlerType: (*CaptchaServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCaptchaConfig",
			Handler:    _CaptchaService_GetCaptchaConfig_Handler,
		},
		{
			MethodName: "CheckCaptcha",
			Handler:    _CaptchaService_CheckCaptcha_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}

const (
	QQEmail_SendQQEmail_FullMethodName  = "/user.QQEmail/SendQQEmail"
	QQEmail_CheckQQEmail_FullMethodName = "/user.QQEmail/CheckQQEmail"
)

// QQEmailClient is the client API for QQEmail service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QQEmailClient interface {
	SendQQEmail(ctx context.Context, in *SendQQEmailReq, opts ...grpc.CallOption) (*SendQQEmailResponse, error)
	CheckQQEmail(ctx context.Context, in *CheckQQEmailReq, opts ...grpc.CallOption) (*CheckQQEmailResponse, error)
}

type qQEmailClient struct {
	cc grpc.ClientConnInterface
}

func NewQQEmailClient(cc grpc.ClientConnInterface) QQEmailClient {
	return &qQEmailClient{cc}
}

func (c *qQEmailClient) SendQQEmail(ctx context.Context, in *SendQQEmailReq, opts ...grpc.CallOption) (*SendQQEmailResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendQQEmailResponse)
	err := c.cc.Invoke(ctx, QQEmail_SendQQEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qQEmailClient) CheckQQEmail(ctx context.Context, in *CheckQQEmailReq, opts ...grpc.CallOption) (*CheckQQEmailResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckQQEmailResponse)
	err := c.cc.Invoke(ctx, QQEmail_CheckQQEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QQEmailServer is the server API for QQEmail service.
// All implementations must embed UnimplementedQQEmailServer
// for forward compatibility.
type QQEmailServer interface {
	SendQQEmail(context.Context, *SendQQEmailReq) (*SendQQEmailResponse, error)
	CheckQQEmail(context.Context, *CheckQQEmailReq) (*CheckQQEmailResponse, error)
	mustEmbedUnimplementedQQEmailServer()
}

// UnimplementedQQEmailServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedQQEmailServer struct{}

func (UnimplementedQQEmailServer) SendQQEmail(context.Context, *SendQQEmailReq) (*SendQQEmailResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SendQQEmail not implemented")
}
func (UnimplementedQQEmailServer) CheckQQEmail(context.Context, *CheckQQEmailReq) (*CheckQQEmailResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckQQEmail not implemented")
}
func (UnimplementedQQEmailServer) mustEmbedUnimplementedQQEmailServer() {}
func (UnimplementedQQEmailServer) testEmbeddedByValue()                 {}

// UnsafeQQEmailServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QQEmailServer will
// result in compilation errors.
type UnsafeQQEmailServer interface {
	mustEmbedUnimplementedQQEmailServer()
}

func RegisterQQEmailServer(s grpc.ServiceRegistrar, srv QQEmailServer) {
	// If the following call panics, it indicates UnimplementedQQEmailServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&QQEmail_ServiceDesc, srv)
}

func _QQEmail_SendQQEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendQQEmailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QQEmailServer).SendQQEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QQEmail_SendQQEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QQEmailServer).SendQQEmail(ctx, req.(*SendQQEmailReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _QQEmail_CheckQQEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckQQEmailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QQEmailServer).CheckQQEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QQEmail_CheckQQEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QQEmailServer).CheckQQEmail(ctx, req.(*CheckQQEmailReq))
	}
	return interceptor(ctx, in, info, handler)
}

// QQEmail_ServiceDesc is the grpc.ServiceDesc for QQEmail service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var QQEmail_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.QQEmail",
	HandlerType: (*QQEmailServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendQQEmail",
			Handler:    _QQEmail_SendQQEmail_Handler,
		},
		{
			MethodName: "CheckQQEmail",
			Handler:    _QQEmail_CheckQQEmail_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}

const (
	UploadToQiNiu_UploadAvatar_FullMethodName            = "/user.UploadToQiNiu/UploadAvatar"
	UploadToQiNiu_UploadStudentCardImages_FullMethodName = "/user.UploadToQiNiu/UploadStudentCardImages"
	UploadToQiNiu_UploadActivityCover_FullMethodName     = "/user.UploadToQiNiu/UploadActivityCover"
	UploadToQiNiu_UploadSysImage_FullMethodName          = "/user.UploadToQiNiu/UploadSysImage"
)

// UploadToQiNiuClient is the client API for UploadToQiNiu service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UploadToQiNiuClient interface {
	// 直接上传用户头像（删除旧图并更新DB）
	UploadAvatar(ctx context.Context, in *UploadAvatarReq, opts ...grpc.CallOption) (*UploadAvatarResp, error)
	// 上传学生认证图片（同时处理旧图删除和DB更新）
	UploadStudentCardImages(ctx context.Context, in *UploadStudentCardImagesReq, opts ...grpc.CallOption) (*UploadStudentCardImagesResp, error)
	// 上传活动封面
	UploadActivityCover(ctx context.Context, in *UploadActivityCoverReq, opts ...grpc.CallOption) (*UploadActivityCoverResp, error)
	// 上传通用图片并入库
	UploadSysImage(ctx context.Context, in *UploadSysImageReq, opts ...grpc.CallOption) (*UploadSysImageResp, error)
}

type uploadToQiNiuClient struct {
	cc grpc.ClientConnInterface
}

func NewUploadToQiNiuClient(cc grpc.ClientConnInterface) UploadToQiNiuClient {
	return &uploadToQiNiuClient{cc}
}

func (c *uploadToQiNiuClient) UploadAvatar(ctx context.Context, in *UploadAvatarReq, opts ...grpc.CallOption) (*UploadAvatarResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadAvatarResp)
	err := c.cc.Invoke(ctx, UploadToQiNiu_UploadAvatar_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uploadToQiNiuClient) UploadStudentCardImages(ctx context.Context, in *UploadStudentCardImagesReq, opts ...grpc.CallOption) (*UploadStudentCardImagesResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadStudentCardImagesResp)
	err := c.cc.Invoke(ctx, UploadToQiNiu_UploadStudentCardImages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uploadToQiNiuClient) UploadActivityCover(ctx context.Context, in *UploadActivityCoverReq, opts ...grpc.CallOption) (*UploadActivityCoverResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadActivityCoverResp)
	err := c.cc.Invoke(ctx, UploadToQiNiu_UploadActivityCover_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uploadToQiNiuClient) UploadSysImage(ctx context.Context, in *UploadSysImageReq, opts ...grpc.CallOption) (*UploadSysImageResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadSysImageResp)
	err := c.cc.Invoke(ctx, UploadToQiNiu_UploadSysImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UploadToQiNiuServer is the server API for UploadToQiNiu service.
// All implementations must embed UnimplementedUploadToQiNiuServer
// for forward compatibility.
type UploadToQiNiuServer interface {
	// 直接上传用户头像（删除旧图并更新DB）
	UploadAvatar(context.Context, *UploadAvatarReq) (*UploadAvatarResp, error)
	// 上传学生认证图片（同时处理旧图删除和DB更新）
	UploadStudentCardImages(context.Context, *UploadStudentCardImagesReq) (*UploadStudentCardImagesResp, error)
	// 上传活动封面
	UploadActivityCover(context.Context, *UploadActivityCoverReq) (*UploadActivityCoverResp, error)
	// 上传通用图片并入库
	UploadSysImage(context.Context, *UploadSysImageReq) (*UploadSysImageResp, error)
	mustEmbedUnimplementedUploadToQiNiuServer()
}

// UnimplementedUploadToQiNiuServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUploadToQiNiuServer struct{}

func (UnimplementedUploadToQiNiuServer) UploadAvatar(context.Context, *UploadAvatarReq) (*UploadAvatarResp, error) {
	return nil, status.Error(codes.Unimplemented, "method UploadAvatar not implemented")
}
func (UnimplementedUploadToQiNiuServer) UploadStudentCardImages(context.Context, *UploadStudentCardImagesReq) (*UploadStudentCardImagesResp, error) {
	return nil, status.Error(codes.Unimplemented, "method UploadStudentCardImages not implemented")
}
func (UnimplementedUploadToQiNiuServer) UploadActivityCover(context.Context, *UploadActivityCoverReq) (*UploadActivityCoverResp, error) {
	return nil, status.Error(codes.Unimplemented, "method UploadActivityCover not implemented")
}
func (UnimplementedUploadToQiNiuServer) UploadSysImage(context.Context, *UploadSysImageReq) (*UploadSysImageResp, error) {
	return nil, status.Error(codes.Unimplemented, "method UploadSysImage not implemented")
}
func (UnimplementedUploadToQiNiuServer) mustEmbedUnimplementedUploadToQiNiuServer() {}
func (UnimplementedUploadToQiNiuServer) testEmbeddedByValue()                       {}

// UnsafeUploadToQiNiuServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UploadToQiNiuServer will
// result in compilation errors.
type UnsafeUploadToQiNiuServer interface {
	mustEmbedUnimplementedUploadToQiNiuServer()
}

func RegisterUploadToQiNiuServer(s grpc.ServiceRegistrar, srv UploadToQiNiuServer) {
	// If the following call panics, it indicates UnimplementedUploadToQiNiuServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UploadToQiNiu_ServiceDesc, srv)
}

func _UploadToQiNiu_UploadAvatar_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadAvatarReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadToQiNiuServer).UploadAvatar(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UploadToQiNiu_UploadAvatar_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadToQiNiuServer).UploadAvatar(ctx, req.(*UploadAvatarReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UploadToQiNiu_UploadStudentCardImages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadStudentCardImagesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadToQiNiuServer).UploadStudentCardImages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UploadToQiNiu_UploadStudentCardImages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadToQiNiuServer).UploadStudentCardImages(ctx, req.(*UploadStudentCardImagesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UploadToQiNiu_UploadActivityCover_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadActivityCoverReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadToQiNiuServer).UploadActivityCover(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UploadToQiNiu_UploadActivityCover_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadToQiNiuServer).UploadActivityCover(ctx, req.(*UploadActivityCoverReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UploadToQiNiu_UploadSysImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadSysImageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadToQiNiuServer).UploadSysImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UploadToQiNiu_UploadSysImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadToQiNiuServer).UploadSysImage(ctx, req.(*UploadSysImageReq))
	}
	return interceptor(ctx, in, info, handler)
}

// UploadToQiNiu_ServiceDesc is the grpc.ServiceDesc for UploadToQiNiu service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UploadToQiNiu_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.UploadToQiNiu",
	HandlerType: (*UploadToQiNiuServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UploadAvatar",
			Handler:    _UploadToQiNiu_UploadAvatar_Handler,
		},
		{
			MethodName: "UploadStudentCardImages",
			Handler:    _UploadToQiNiu_UploadStudentCardImages_Handler,
		},
		{
			MethodName: "UploadActivityCover",
			Handler:    _UploadToQiNiu_UploadActivityCover_Handler,
		},
		{
			MethodName: "UploadSysImage",
			Handler:    _UploadToQiNiu_UploadSysImage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}
