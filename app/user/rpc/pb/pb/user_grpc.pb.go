// ============================================================================
// User 模块 Proto 定义文件
// ============================================================================
//
// 文件说明：
//   定义 User 模块的内部 gRPC 服务接口，供【其他微服务】调用。
//   不对外暴露，不经过 Gateway。
//
// 包含服务：
//   - CreditService: 信用分服务
//   - VerifyService: 学生认证服务
//
// 调用方：
//   - Activity RPC（报名/发布权限校验）
//   - MQ Consumer（信用分变更）
//   - User API（查询信用信息）
//
// 字段编号规划：
//   - 1-30: 基础字段
//   - 31-50: 扩展字段
//   警告：字段编号一旦发布使用后不可更改或复用！
//
// 生成命令：
//   cd app/user/rpc
//   goctl rpc protoc user.proto --go_out=./pb --go-grpc_out=./pb --zrpc_out=. -style go_zero
//
// ============================================================================

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.4
// source: user.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	CreditService_GetCreditInfo_FullMethodName  = "/user.CreditService/GetCreditInfo"
	CreditService_GetCreditLogs_FullMethodName  = "/user.CreditService/GetCreditLogs"
	CreditService_CanParticipate_FullMethodName = "/user.CreditService/CanParticipate"
	CreditService_CanPublish_FullMethodName     = "/user.CreditService/CanPublish"
	CreditService_InitCredit_FullMethodName     = "/user.CreditService/InitCredit"
	CreditService_UpdateScore_FullMethodName    = "/user.CreditService/UpdateScore"
)

// CreditServiceClient is the client API for CreditService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CreditServiceClient interface {
	// GetCreditInfo 获取用户信用信息
	// 调用方: User API（个人中心-信用信息页面）
	// 业务逻辑: 返回用户当前的信用分、等级、特权信息
	GetCreditInfo(ctx context.Context, in *GetCreditInfoReq, opts ...grpc.CallOption) (*GetCreditInfoResp, error)
	// GetCreditLogs 获取信用变更记录列表
	// 调用方: User API（信用分明细页面）
	// 业务逻辑: 分页查询用户的信用变更记录，支持按类型和时间筛选
	GetCreditLogs(ctx context.Context, in *GetCreditLogsReq, opts ...grpc.CallOption) (*GetCreditLogsResp, error)
	// CanParticipate 校验是否允许报名
	// 调用方: Activity服务（报名模块）
	// 业务逻辑:
	//   - score < 60: 黑名单，禁止报名
	//   - 60 <= score < 70: 风险用户，每日限报名1次
	//   - score >= 70: 正常报名
	CanParticipate(ctx context.Context, in *CanParticipateReq, opts ...grpc.CallOption) (*CanParticipateResp, error)
	// CanPublish 校验是否允许发布活动
	// 调用方: Activity服务（发布模块）
	// 业务逻辑:
	//   - score >= 90: 允许发布（Lv3优秀用户、Lv4社区之星）
	//   - score < 90: 禁止发布
	CanPublish(ctx context.Context, in *CanPublishReq, opts ...grpc.CallOption) (*CanPublishResp, error)
	// InitCredit 初始化信用分
	// 调用方: User服务（注册流程）
	// 业务逻辑: 用户注册成功后初始化信用分为100分（Lv4社区之星）
	InitCredit(ctx context.Context, in *InitCreditReq, opts ...grpc.CallOption) (*InitCreditResp, error)
	// UpdateScore 变更信用分
	// 调用方: MQ Consumer（内部系统）
	// 业务逻辑: 签到、爽约、活动结束等事件触发信用分变更
	// 幂等保证: 通过 source_id 实现幂等
	UpdateScore(ctx context.Context, in *UpdateScoreReq, opts ...grpc.CallOption) (*UpdateScoreResp, error)
}

type creditServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCreditServiceClient(cc grpc.ClientConnInterface) CreditServiceClient {
	return &creditServiceClient{cc}
}

func (c *creditServiceClient) GetCreditInfo(ctx context.Context, in *GetCreditInfoReq, opts ...grpc.CallOption) (*GetCreditInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCreditInfoResp)
	err := c.cc.Invoke(ctx, CreditService_GetCreditInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *creditServiceClient) GetCreditLogs(ctx context.Context, in *GetCreditLogsReq, opts ...grpc.CallOption) (*GetCreditLogsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCreditLogsResp)
	err := c.cc.Invoke(ctx, CreditService_GetCreditLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *creditServiceClient) CanParticipate(ctx context.Context, in *CanParticipateReq, opts ...grpc.CallOption) (*CanParticipateResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CanParticipateResp)
	err := c.cc.Invoke(ctx, CreditService_CanParticipate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *creditServiceClient) CanPublish(ctx context.Context, in *CanPublishReq, opts ...grpc.CallOption) (*CanPublishResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CanPublishResp)
	err := c.cc.Invoke(ctx, CreditService_CanPublish_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *creditServiceClient) InitCredit(ctx context.Context, in *InitCreditReq, opts ...grpc.CallOption) (*InitCreditResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InitCreditResp)
	err := c.cc.Invoke(ctx, CreditService_InitCredit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *creditServiceClient) UpdateScore(ctx context.Context, in *UpdateScoreReq, opts ...grpc.CallOption) (*UpdateScoreResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateScoreResp)
	err := c.cc.Invoke(ctx, CreditService_UpdateScore_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CreditServiceServer is the server API for CreditService service.
// All implementations must embed UnimplementedCreditServiceServer
// for forward compatibility.
type CreditServiceServer interface {
	// GetCreditInfo 获取用户信用信息
	// 调用方: User API（个人中心-信用信息页面）
	// 业务逻辑: 返回用户当前的信用分、等级、特权信息
	GetCreditInfo(context.Context, *GetCreditInfoReq) (*GetCreditInfoResp, error)
	// GetCreditLogs 获取信用变更记录列表
	// 调用方: User API（信用分明细页面）
	// 业务逻辑: 分页查询用户的信用变更记录，支持按类型和时间筛选
	GetCreditLogs(context.Context, *GetCreditLogsReq) (*GetCreditLogsResp, error)
	// CanParticipate 校验是否允许报名
	// 调用方: Activity服务（报名模块）
	// 业务逻辑:
	//   - score < 60: 黑名单，禁止报名
	//   - 60 <= score < 70: 风险用户，每日限报名1次
	//   - score >= 70: 正常报名
	CanParticipate(context.Context, *CanParticipateReq) (*CanParticipateResp, error)
	// CanPublish 校验是否允许发布活动
	// 调用方: Activity服务（发布模块）
	// 业务逻辑:
	//   - score >= 90: 允许发布（Lv3优秀用户、Lv4社区之星）
	//   - score < 90: 禁止发布
	CanPublish(context.Context, *CanPublishReq) (*CanPublishResp, error)
	// InitCredit 初始化信用分
	// 调用方: User服务（注册流程）
	// 业务逻辑: 用户注册成功后初始化信用分为100分（Lv4社区之星）
	InitCredit(context.Context, *InitCreditReq) (*InitCreditResp, error)
	// UpdateScore 变更信用分
	// 调用方: MQ Consumer（内部系统）
	// 业务逻辑: 签到、爽约、活动结束等事件触发信用分变更
	// 幂等保证: 通过 source_id 实现幂等
	UpdateScore(context.Context, *UpdateScoreReq) (*UpdateScoreResp, error)
	mustEmbedUnimplementedCreditServiceServer()
}

// UnimplementedCreditServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCreditServiceServer struct{}

func (UnimplementedCreditServiceServer) GetCreditInfo(context.Context, *GetCreditInfoReq) (*GetCreditInfoResp, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCreditInfo not implemented")
}
func (UnimplementedCreditServiceServer) GetCreditLogs(context.Context, *GetCreditLogsReq) (*GetCreditLogsResp, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCreditLogs not implemented")
}
func (UnimplementedCreditServiceServer) CanParticipate(context.Context, *CanParticipateReq) (*CanParticipateResp, error) {
	return nil, status.Error(codes.Unimplemented, "method CanParticipate not implemented")
}
func (UnimplementedCreditServiceServer) CanPublish(context.Context, *CanPublishReq) (*CanPublishResp, error) {
	return nil, status.Error(codes.Unimplemented, "method CanPublish not implemented")
}
func (UnimplementedCreditServiceServer) InitCredit(context.Context, *InitCreditReq) (*InitCreditResp, error) {
	return nil, status.Error(codes.Unimplemented, "method InitCredit not implemented")
}
func (UnimplementedCreditServiceServer) UpdateScore(context.Context, *UpdateScoreReq) (*UpdateScoreResp, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateScore not implemented")
}
func (UnimplementedCreditServiceServer) mustEmbedUnimplementedCreditServiceServer() {}
func (UnimplementedCreditServiceServer) testEmbeddedByValue()                       {}

// UnsafeCreditServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CreditServiceServer will
// result in compilation errors.
type UnsafeCreditServiceServer interface {
	mustEmbedUnimplementedCreditServiceServer()
}

func RegisterCreditServiceServer(s grpc.ServiceRegistrar, srv CreditServiceServer) {
	// If the following call panics, it indicates UnimplementedCreditServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CreditService_ServiceDesc, srv)
}

func _CreditService_GetCreditInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCreditInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreditServiceServer).GetCreditInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CreditService_GetCreditInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreditServiceServer).GetCreditInfo(ctx, req.(*GetCreditInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CreditService_GetCreditLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCreditLogsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreditServiceServer).GetCreditLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CreditService_GetCreditLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreditServiceServer).GetCreditLogs(ctx, req.(*GetCreditLogsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CreditService_CanParticipate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CanParticipateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreditServiceServer).CanParticipate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CreditService_CanParticipate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreditServiceServer).CanParticipate(ctx, req.(*CanParticipateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CreditService_CanPublish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CanPublishReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreditServiceServer).CanPublish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CreditService_CanPublish_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreditServiceServer).CanPublish(ctx, req.(*CanPublishReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CreditService_InitCredit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitCreditReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreditServiceServer).InitCredit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CreditService_InitCredit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreditServiceServer).InitCredit(ctx, req.(*InitCreditReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CreditService_UpdateScore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateScoreReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreditServiceServer).UpdateScore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CreditService_UpdateScore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreditServiceServer).UpdateScore(ctx, req.(*UpdateScoreReq))
	}
	return interceptor(ctx, in, info, handler)
}

// CreditService_ServiceDesc is the grpc.ServiceDesc for CreditService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CreditService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.CreditService",
	HandlerType: (*CreditServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCreditInfo",
			Handler:    _CreditService_GetCreditInfo_Handler,
		},
		{
			MethodName: "GetCreditLogs",
			Handler:    _CreditService_GetCreditLogs_Handler,
		},
		{
			MethodName: "CanParticipate",
			Handler:    _CreditService_CanParticipate_Handler,
		},
		{
			MethodName: "CanPublish",
			Handler:    _CreditService_CanPublish_Handler,
		},
		{
			MethodName: "InitCredit",
			Handler:    _CreditService_InitCredit_Handler,
		},
		{
			MethodName: "UpdateScore",
			Handler:    _CreditService_UpdateScore_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}

const (
	VerifyService_GetVerifyCurrent_FullMethodName     = "/user.VerifyService/GetVerifyCurrent"
	VerifyService_GetVerifyInfo_FullMethodName        = "/user.VerifyService/GetVerifyInfo"
	VerifyService_IsVerified_FullMethodName           = "/user.VerifyService/IsVerified"
	VerifyService_ApplyStudentVerify_FullMethodName   = "/user.VerifyService/ApplyStudentVerify"
	VerifyService_ConfirmStudentVerify_FullMethodName = "/user.VerifyService/ConfirmStudentVerify"
	VerifyService_CancelStudentVerify_FullMethodName  = "/user.VerifyService/CancelStudentVerify"
	VerifyService_UpdateVerifyStatus_FullMethodName   = "/user.VerifyService/UpdateVerifyStatus"
)

// VerifyServiceClient is the client API for VerifyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VerifyServiceClient interface {
	// GetVerifyCurrent 获取当前认证进度
	// 调用方: User API（进入认证页面时调用）
	// 业务逻辑: 返回用户当前的认证状态、可执行的操作、OCR识别数据等
	GetVerifyCurrent(ctx context.Context, in *GetVerifyCurrentReq, opts ...grpc.CallOption) (*GetVerifyCurrentResp, error)
	// GetVerifyInfo 获取已通过的认证信息
	// 调用方: User API（个人中心-认证信息页面）
	// 业务逻辑: 仅返回已通过认证用户的脱敏信息
	GetVerifyInfo(ctx context.Context, in *GetVerifyInfoReq, opts ...grpc.CallOption) (*GetVerifyInfoResp, error)
	// IsVerified 查询用户是否已完成学生认证
	// 调用方: Activity服务（报名/发布活动前校验）
	// 场景: 需要确认用户学生身份时调用
	IsVerified(ctx context.Context, in *IsVerifiedReq, opts ...grpc.CallOption) (*IsVerifiedResp, error)
	// ApplyStudentVerify 提交学生认证申请
	// 调用方: User API
	// 业务逻辑:
	//  1. 限流检查（20s内≤2次）
	//  2. 唯一性校验（学校+学号）
	//  3. 状态机校验
	//  4. 创建记录并触发OCR
	ApplyStudentVerify(ctx context.Context, in *ApplyStudentVerifyReq, opts ...grpc.CallOption) (*ApplyStudentVerifyResp, error)
	// ConfirmStudentVerify 用户确认/修改认证信息
	// 调用方: User API
	// 业务逻辑:
	//   - 确认无误 -> 状态改为4（已通过）
	//   - 修改信息 -> 状态改为3（人工审核）
	ConfirmStudentVerify(ctx context.Context, in *ConfirmStudentVerifyReq, opts ...grpc.CallOption) (*ConfirmStudentVerifyResp, error)
	// CancelStudentVerify 取消认证申请
	// 调用方: User API
	// 业务逻辑: 状态改为7（已取消）
	CancelStudentVerify(ctx context.Context, in *CancelStudentVerifyReq, opts ...grpc.CallOption) (*CancelStudentVerifyResp, error)
	// UpdateVerifyStatus 更新认证状态
	// 调用方: MQ Consumer（OCR回调、人工审核结果）、定时任务（超时处理）
	// 业务逻辑: 处理认证流程中的状态流转
	UpdateVerifyStatus(ctx context.Context, in *UpdateVerifyStatusReq, opts ...grpc.CallOption) (*UpdateVerifyStatusResp, error)
}

type verifyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVerifyServiceClient(cc grpc.ClientConnInterface) VerifyServiceClient {
	return &verifyServiceClient{cc}
}

func (c *verifyServiceClient) GetVerifyCurrent(ctx context.Context, in *GetVerifyCurrentReq, opts ...grpc.CallOption) (*GetVerifyCurrentResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetVerifyCurrentResp)
	err := c.cc.Invoke(ctx, VerifyService_GetVerifyCurrent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifyServiceClient) GetVerifyInfo(ctx context.Context, in *GetVerifyInfoReq, opts ...grpc.CallOption) (*GetVerifyInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetVerifyInfoResp)
	err := c.cc.Invoke(ctx, VerifyService_GetVerifyInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifyServiceClient) IsVerified(ctx context.Context, in *IsVerifiedReq, opts ...grpc.CallOption) (*IsVerifiedResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsVerifiedResp)
	err := c.cc.Invoke(ctx, VerifyService_IsVerified_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifyServiceClient) ApplyStudentVerify(ctx context.Context, in *ApplyStudentVerifyReq, opts ...grpc.CallOption) (*ApplyStudentVerifyResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApplyStudentVerifyResp)
	err := c.cc.Invoke(ctx, VerifyService_ApplyStudentVerify_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifyServiceClient) ConfirmStudentVerify(ctx context.Context, in *ConfirmStudentVerifyReq, opts ...grpc.CallOption) (*ConfirmStudentVerifyResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfirmStudentVerifyResp)
	err := c.cc.Invoke(ctx, VerifyService_ConfirmStudentVerify_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifyServiceClient) CancelStudentVerify(ctx context.Context, in *CancelStudentVerifyReq, opts ...grpc.CallOption) (*CancelStudentVerifyResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelStudentVerifyResp)
	err := c.cc.Invoke(ctx, VerifyService_CancelStudentVerify_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifyServiceClient) UpdateVerifyStatus(ctx context.Context, in *UpdateVerifyStatusReq, opts ...grpc.CallOption) (*UpdateVerifyStatusResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateVerifyStatusResp)
	err := c.cc.Invoke(ctx, VerifyService_UpdateVerifyStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VerifyServiceServer is the server API for VerifyService service.
// All implementations must embed UnimplementedVerifyServiceServer
// for forward compatibility.
type VerifyServiceServer interface {
	// GetVerifyCurrent 获取当前认证进度
	// 调用方: User API（进入认证页面时调用）
	// 业务逻辑: 返回用户当前的认证状态、可执行的操作、OCR识别数据等
	GetVerifyCurrent(context.Context, *GetVerifyCurrentReq) (*GetVerifyCurrentResp, error)
	// GetVerifyInfo 获取已通过的认证信息
	// 调用方: User API（个人中心-认证信息页面）
	// 业务逻辑: 仅返回已通过认证用户的脱敏信息
	GetVerifyInfo(context.Context, *GetVerifyInfoReq) (*GetVerifyInfoResp, error)
	// IsVerified 查询用户是否已完成学生认证
	// 调用方: Activity服务（报名/发布活动前校验）
	// 场景: 需要确认用户学生身份时调用
	IsVerified(context.Context, *IsVerifiedReq) (*IsVerifiedResp, error)
	// ApplyStudentVerify 提交学生认证申请
	// 调用方: User API
	// 业务逻辑:
	//  1. 限流检查（20s内≤2次）
	//  2. 唯一性校验（学校+学号）
	//  3. 状态机校验
	//  4. 创建记录并触发OCR
	ApplyStudentVerify(context.Context, *ApplyStudentVerifyReq) (*ApplyStudentVerifyResp, error)
	// ConfirmStudentVerify 用户确认/修改认证信息
	// 调用方: User API
	// 业务逻辑:
	//   - 确认无误 -> 状态改为4（已通过）
	//   - 修改信息 -> 状态改为3（人工审核）
	ConfirmStudentVerify(context.Context, *ConfirmStudentVerifyReq) (*ConfirmStudentVerifyResp, error)
	// CancelStudentVerify 取消认证申请
	// 调用方: User API
	// 业务逻辑: 状态改为7（已取消）
	CancelStudentVerify(context.Context, *CancelStudentVerifyReq) (*CancelStudentVerifyResp, error)
	// UpdateVerifyStatus 更新认证状态
	// 调用方: MQ Consumer（OCR回调、人工审核结果）、定时任务（超时处理）
	// 业务逻辑: 处理认证流程中的状态流转
	UpdateVerifyStatus(context.Context, *UpdateVerifyStatusReq) (*UpdateVerifyStatusResp, error)
	mustEmbedUnimplementedVerifyServiceServer()
}

// UnimplementedVerifyServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVerifyServiceServer struct{}

func (UnimplementedVerifyServiceServer) GetVerifyCurrent(context.Context, *GetVerifyCurrentReq) (*GetVerifyCurrentResp, error) {
	return nil, status.Error(codes.Unimplemented, "method GetVerifyCurrent not implemented")
}
func (UnimplementedVerifyServiceServer) GetVerifyInfo(context.Context, *GetVerifyInfoReq) (*GetVerifyInfoResp, error) {
	return nil, status.Error(codes.Unimplemented, "method GetVerifyInfo not implemented")
}
func (UnimplementedVerifyServiceServer) IsVerified(context.Context, *IsVerifiedReq) (*IsVerifiedResp, error) {
	return nil, status.Error(codes.Unimplemented, "method IsVerified not implemented")
}
func (UnimplementedVerifyServiceServer) ApplyStudentVerify(context.Context, *ApplyStudentVerifyReq) (*ApplyStudentVerifyResp, error) {
	return nil, status.Error(codes.Unimplemented, "method ApplyStudentVerify not implemented")
}
func (UnimplementedVerifyServiceServer) ConfirmStudentVerify(context.Context, *ConfirmStudentVerifyReq) (*ConfirmStudentVerifyResp, error) {
	return nil, status.Error(codes.Unimplemented, "method ConfirmStudentVerify not implemented")
}
func (UnimplementedVerifyServiceServer) CancelStudentVerify(context.Context, *CancelStudentVerifyReq) (*CancelStudentVerifyResp, error) {
	return nil, status.Error(codes.Unimplemented, "method CancelStudentVerify not implemented")
}
func (UnimplementedVerifyServiceServer) UpdateVerifyStatus(context.Context, *UpdateVerifyStatusReq) (*UpdateVerifyStatusResp, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateVerifyStatus not implemented")
}
func (UnimplementedVerifyServiceServer) mustEmbedUnimplementedVerifyServiceServer() {}
func (UnimplementedVerifyServiceServer) testEmbeddedByValue()                       {}

// UnsafeVerifyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VerifyServiceServer will
// result in compilation errors.
type UnsafeVerifyServiceServer interface {
	mustEmbedUnimplementedVerifyServiceServer()
}

func RegisterVerifyServiceServer(s grpc.ServiceRegistrar, srv VerifyServiceServer) {
	// If the following call panics, it indicates UnimplementedVerifyServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VerifyService_ServiceDesc, srv)
}

func _VerifyService_GetVerifyCurrent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVerifyCurrentReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifyServiceServer).GetVerifyCurrent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VerifyService_GetVerifyCurrent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifyServiceServer).GetVerifyCurrent(ctx, req.(*GetVerifyCurrentReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifyService_GetVerifyInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVerifyInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifyServiceServer).GetVerifyInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VerifyService_GetVerifyInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifyServiceServer).GetVerifyInfo(ctx, req.(*GetVerifyInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifyService_IsVerified_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsVerifiedReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifyServiceServer).IsVerified(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VerifyService_IsVerified_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifyServiceServer).IsVerified(ctx, req.(*IsVerifiedReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifyService_ApplyStudentVerify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyStudentVerifyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifyServiceServer).ApplyStudentVerify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VerifyService_ApplyStudentVerify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifyServiceServer).ApplyStudentVerify(ctx, req.(*ApplyStudentVerifyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifyService_ConfirmStudentVerify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfirmStudentVerifyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifyServiceServer).ConfirmStudentVerify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VerifyService_ConfirmStudentVerify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifyServiceServer).ConfirmStudentVerify(ctx, req.(*ConfirmStudentVerifyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifyService_CancelStudentVerify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelStudentVerifyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifyServiceServer).CancelStudentVerify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VerifyService_CancelStudentVerify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifyServiceServer).CancelStudentVerify(ctx, req.(*CancelStudentVerifyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifyService_UpdateVerifyStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateVerifyStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifyServiceServer).UpdateVerifyStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VerifyService_UpdateVerifyStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifyServiceServer).UpdateVerifyStatus(ctx, req.(*UpdateVerifyStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

// VerifyService_ServiceDesc is the grpc.ServiceDesc for VerifyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VerifyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.VerifyService",
	HandlerType: (*VerifyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVerifyCurrent",
			Handler:    _VerifyService_GetVerifyCurrent_Handler,
		},
		{
			MethodName: "GetVerifyInfo",
			Handler:    _VerifyService_GetVerifyInfo_Handler,
		},
		{
			MethodName: "IsVerified",
			Handler:    _VerifyService_IsVerified_Handler,
		},
		{
			MethodName: "ApplyStudentVerify",
			Handler:    _VerifyService_ApplyStudentVerify_Handler,
		},
		{
			MethodName: "ConfirmStudentVerify",
			Handler:    _VerifyService_ConfirmStudentVerify_Handler,
		},
		{
			MethodName: "CancelStudentVerify",
			Handler:    _VerifyService_CancelStudentVerify_Handler,
		},
		{
			MethodName: "UpdateVerifyStatus",
			Handler:    _VerifyService_UpdateVerifyStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}

const (
	TagService_GetAllTags_FullMethodName   = "/user.TagService/GetAllTags"
	TagService_GetTagsByIds_FullMethodName = "/user.TagService/GetTagsByIds"
	TagService_GetUserTags_FullMethodName  = "/user.TagService/GetUserTags"
)

// TagServiceClient is the client API for TagService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TagServiceClient interface {
	GetAllTags(ctx context.Context, in *GetAllTagsReq, opts ...grpc.CallOption) (*GetAllTagsResp, error)
	GetTagsByIds(ctx context.Context, in *GetTagsByIdsReq, opts ...grpc.CallOption) (*GetTagsByIdsResp, error)
	GetUserTags(ctx context.Context, in *GetUserTagsRep, opts ...grpc.CallOption) (*GetUserTagsResponse, error)
}

type tagServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTagServiceClient(cc grpc.ClientConnInterface) TagServiceClient {
	return &tagServiceClient{cc}
}

func (c *tagServiceClient) GetAllTags(ctx context.Context, in *GetAllTagsReq, opts ...grpc.CallOption) (*GetAllTagsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllTagsResp)
	err := c.cc.Invoke(ctx, TagService_GetAllTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagServiceClient) GetTagsByIds(ctx context.Context, in *GetTagsByIdsReq, opts ...grpc.CallOption) (*GetTagsByIdsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTagsByIdsResp)
	err := c.cc.Invoke(ctx, TagService_GetTagsByIds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagServiceClient) GetUserTags(ctx context.Context, in *GetUserTagsRep, opts ...grpc.CallOption) (*GetUserTagsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserTagsResponse)
	err := c.cc.Invoke(ctx, TagService_GetUserTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TagServiceServer is the server API for TagService service.
// All implementations must embed UnimplementedTagServiceServer
// for forward compatibility.
type TagServiceServer interface {
	GetAllTags(context.Context, *GetAllTagsReq) (*GetAllTagsResp, error)
	GetTagsByIds(context.Context, *GetTagsByIdsReq) (*GetTagsByIdsResp, error)
	GetUserTags(context.Context, *GetUserTagsRep) (*GetUserTagsResponse, error)
	mustEmbedUnimplementedTagServiceServer()
}

// UnimplementedTagServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTagServiceServer struct{}

func (UnimplementedTagServiceServer) GetAllTags(context.Context, *GetAllTagsReq) (*GetAllTagsResp, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAllTags not implemented")
}
func (UnimplementedTagServiceServer) GetTagsByIds(context.Context, *GetTagsByIdsReq) (*GetTagsByIdsResp, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTagsByIds not implemented")
}
func (UnimplementedTagServiceServer) GetUserTags(context.Context, *GetUserTagsRep) (*GetUserTagsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUserTags not implemented")
}
func (UnimplementedTagServiceServer) mustEmbedUnimplementedTagServiceServer() {}
func (UnimplementedTagServiceServer) testEmbeddedByValue()                    {}

// UnsafeTagServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TagServiceServer will
// result in compilation errors.
type UnsafeTagServiceServer interface {
	mustEmbedUnimplementedTagServiceServer()
}

func RegisterTagServiceServer(s grpc.ServiceRegistrar, srv TagServiceServer) {
	// If the following call panics, it indicates UnimplementedTagServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TagService_ServiceDesc, srv)
}

func _TagService_GetAllTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllTagsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).GetAllTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_GetAllTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).GetAllTags(ctx, req.(*GetAllTagsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagService_GetTagsByIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTagsByIdsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).GetTagsByIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_GetTagsByIds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).GetTagsByIds(ctx, req.(*GetTagsByIdsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagService_GetUserTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserTagsRep)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).GetUserTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_GetUserTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).GetUserTags(ctx, req.(*GetUserTagsRep))
	}
	return interceptor(ctx, in, info, handler)
}

// TagService_ServiceDesc is the grpc.ServiceDesc for TagService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TagService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.TagService",
	HandlerType: (*TagServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllTags",
			Handler:    _TagService_GetAllTags_Handler,
		},
		{
			MethodName: "GetTagsByIds",
			Handler:    _TagService_GetTagsByIds_Handler,
		},
		{
			MethodName: "GetUserTags",
			Handler:    _TagService_GetUserTags_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}

const (
	UserBasicService_GetGroupUser_FullMethodName = "/user.UserBasicService/GetGroupUser"
)

// UserBasicServiceClient is the client API for UserBasicService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserBasicServiceClient interface {
	GetGroupUser(ctx context.Context, in *GetGroupUserRep, opts ...grpc.CallOption) (*GetGroupUserResponse, error)
}

type userBasicServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserBasicServiceClient(cc grpc.ClientConnInterface) UserBasicServiceClient {
	return &userBasicServiceClient{cc}
}

func (c *userBasicServiceClient) GetGroupUser(ctx context.Context, in *GetGroupUserRep, opts ...grpc.CallOption) (*GetGroupUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGroupUserResponse)
	err := c.cc.Invoke(ctx, UserBasicService_GetGroupUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserBasicServiceServer is the server API for UserBasicService service.
// All implementations must embed UnimplementedUserBasicServiceServer
// for forward compatibility.
type UserBasicServiceServer interface {
	GetGroupUser(context.Context, *GetGroupUserRep) (*GetGroupUserResponse, error)
	mustEmbedUnimplementedUserBasicServiceServer()
}

// UnimplementedUserBasicServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserBasicServiceServer struct{}

func (UnimplementedUserBasicServiceServer) GetGroupUser(context.Context, *GetGroupUserRep) (*GetGroupUserResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetGroupUser not implemented")
}
func (UnimplementedUserBasicServiceServer) mustEmbedUnimplementedUserBasicServiceServer() {}
func (UnimplementedUserBasicServiceServer) testEmbeddedByValue()                          {}

// UnsafeUserBasicServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserBasicServiceServer will
// result in compilation errors.
type UnsafeUserBasicServiceServer interface {
	mustEmbedUnimplementedUserBasicServiceServer()
}

func RegisterUserBasicServiceServer(s grpc.ServiceRegistrar, srv UserBasicServiceServer) {
	// If the following call panics, it indicates UnimplementedUserBasicServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserBasicService_ServiceDesc, srv)
}

func _UserBasicService_GetGroupUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGroupUserRep)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserBasicServiceServer).GetGroupUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserBasicService_GetGroupUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserBasicServiceServer).GetGroupUser(ctx, req.(*GetGroupUserRep))
	}
	return interceptor(ctx, in, info, handler)
}

// UserBasicService_ServiceDesc is the grpc.ServiceDesc for UserBasicService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserBasicService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.UserBasicService",
	HandlerType: (*UserBasicServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetGroupUser",
			Handler:    _UserBasicService_GetGroupUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}
