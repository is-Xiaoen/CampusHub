# 信用分消息队列对接文档

> **版本**: 1.0  
> **作者**: User 模块  
> **日期**: 2026-02-05  
> **状态**: User MQ 消费端已完成，等待 Activity 模块发布事件

---

## 1. 系统架构

```
┌─────────────────┐    消息事件      ┌─────────────────┐
│  Activity RPC   │ ───────────────► │   User MQ       │
│ (发布信用事件)   │  Redis Stream   │ (消费处理)       │
└─────────────────┘                  └────────┬────────┘
                                              │ 更新
                                              ▼
┌─────────────────┐                  ┌─────────────────┐
│   Activity API  │ ◄───── RPC ────► │   User RPC      │
│   (校验资格)     │                  │ (信用分服务)     │
└─────────────────┘                  └────────┬────────┘
                                              │
                           ┌──────────────────┼──────────────────┐
                           ▼                  ▼                  ▼
                    ┌──────────┐       ┌──────────┐       ┌──────────┐
                    │  Redis   │       │  MySQL   │       │  Redis   │
                    │ (缓存层)  │◄─────►│ (持久层)  │       │ (Stream) │
                    └──────────┘       └──────────┘       └──────────┘
```

### 模块职责

| 模块 | 职责 | 状态 |
|------|------|------|
| **Activity RPC** | 在业务节点发布信用事件到 Redis Stream | ⏳ 待实现 |
| **User MQ** | 消费 Redis Stream 消息，更新信用分 | ✅ 已完成 |
| **User RPC** | 提供信用分查询、资格校验接口 | ✅ 已完成 |
| **Activity API** | 调用 User RPC 校验报名/发布资格 | ✅ 已完成 |

---

## 2. Redis Stream 配置

### 2.1 Stream Key

```go
// 定义位置: common/constants/redis_key.go
const StreamCreditEvents = "credit:events"
```

### 2.2 消费者组信息

| 配置项 | 值 | 说明 |
|--------|-----|------|
| Stream Key | `credit:events` | 信用事件消息流 |
| Consumer Group | `user-mq-group` | 消费者组名称 |
| Consumer Name | `consumer-1` | 消费者实例名（集群部署时不同） |

### 2.3 创建消费者组（首次部署）

Activity 服务首次发布消息前，需要确保消费者组已创建：

```bash
# 创建消费者组（如果 Stream 不存在会自动创建）
redis-cli XGROUP CREATE credit:events user-mq-group $ MKSTREAM
```

或在代码中自动创建：

```go
// 创建消费者组（忽略已存在错误）
err := rdb.XGroupCreateMkStream(ctx, "credit:events", "user-mq-group", "$").Err()
if err != nil && !strings.Contains(err.Error(), "BUSYGROUP") {
    return err
}
```

---

## 3. 消息格式规范

### 3.1 消息结构

使用 `XADD` 命令发布消息，消息包含两个字段：

| 字段 | 类型 | 说明 |
|------|------|------|
| `type` | string | 消息类型，固定为 `"credit_change"` |
| `data` | string | JSON 格式的事件数据 |

### 3.2 事件数据结构 (CreditEventData)

```go
// 定义位置: app/user/mq/internal/handler/credit_change_handler.go
type CreditEventData struct {
    // Type 事件类型
    // 可选值: checkin | cancel_early | cancel_late | noshow | host_success | host_delete
    Type string `json:"type"`

    // ActivityID 活动ID
    ActivityID int64 `json:"activity_id"`

    // UserID 用户ID（参与者或发起人）
    UserID int64 `json:"user_id"`

    // Timestamp 事件发生时间戳（秒）
    Timestamp int64 `json:"timestamp"`

    // TraceID 链路追踪ID（可选，用于日志追踪）
    TraceID string `json:"trace_id,omitempty"`
}
```

### 3.3 事件类型与分值变动

| 事件类型 | 场景说明 | 分值变动 | 触发位置 |
|---------|---------|----------|---------|
| `checkin` | 签到成功/正常履约 | **+2** | 核销票券时 |
| `cancel_early` | 提前24h取消报名 | **0** | 取消报名（距开始>24h） |
| `cancel_late` | 临期取消报名 | **-5** | 取消报名（距开始<24h） |
| `noshow` | 爽约/未签到 | **-10** | 活动结束时批量处理 |
| `host_success` | 圆满举办活动 | **+5** | 活动结束且签到率达标 |
| `host_delete` | 删除已有报名的活动 | **-10** | 删除活动（有人报名） |

> **分值常量定义**: `common/constants/credit.go`

---

## 4. Activity 模块发布事件示例

### 4.1 通用发布函数

建议在 Activity 服务中封装一个通用的事件发布函数：

```go
package publisher

import (
    "context"
    "encoding/json"
    "time"

    "activity-platform/common/constants"
    "github.com/go-redis/redis/v8"
    "github.com/zeromicro/go-zero/core/logx"
    "github.com/zeromicro/go-zero/core/trace"
)

// CreditEventPublisher 信用事件发布器
type CreditEventPublisher struct {
    rdb *redis.Client
}

// NewCreditEventPublisher 创建发布器
func NewCreditEventPublisher(rdb *redis.Client) *CreditEventPublisher {
    return &CreditEventPublisher{rdb: rdb}
}

// CreditEventData 信用事件数据
type CreditEventData struct {
    Type       string `json:"type"`
    ActivityID int64  `json:"activity_id"`
    UserID     int64  `json:"user_id"`
    Timestamp  int64  `json:"timestamp"`
    TraceID    string `json:"trace_id,omitempty"`
}

// Publish 发布信用事件
func (p *CreditEventPublisher) Publish(ctx context.Context, event *CreditEventData) error {
    // 填充默认值
    if event.Timestamp == 0 {
        event.Timestamp = time.Now().Unix()
    }
    if event.TraceID == "" {
        event.TraceID = trace.TraceIDFromContext(ctx)
    }

    // 序列化事件数据
    data, err := json.Marshal(event)
    if err != nil {
        return err
    }

    // 发布到 Redis Stream
    result, err := p.rdb.XAdd(ctx, &redis.XAddArgs{
        Stream: constants.StreamCreditEvents, // "credit:events"
        Values: map[string]interface{}{
            "type": "credit_change",
            "data": string(data),
        },
    }).Result()

    if err != nil {
        logx.WithContext(ctx).Errorf("[CreditEvent] 发布失败: %v, event=%+v", err, event)
        return err
    }

    logx.WithContext(ctx).Infof("[CreditEvent] 发布成功: msgId=%s, type=%s, userId=%d, activityId=%d",
        result, event.Type, event.UserID, event.ActivityID)
    return nil
}
```

### 4.2 在 ServiceContext 中初始化

```go
// app/activity/rpc/internal/svc/servicecontext.go

import "activity-platform/app/activity/rpc/internal/publisher"

type ServiceContext struct {
    // ... 其他字段
    CreditEventPublisher *publisher.CreditEventPublisher
}

func NewServiceContext(c config.Config) *ServiceContext {
    rdb := initRedis(c)
    return &ServiceContext{
        // ... 其他初始化
        CreditEventPublisher: publisher.NewCreditEventPublisher(rdb),
    }
}
```

### 4.3 各场景发布示例

#### 场景1: 核销票券（签到成功）

```go
// verify_ticket_logic.go
func (l *VerifyTicketLogic) VerifyTicket(in *pb.VerifyTicketReq) (*pb.VerifyTicketResp, error) {
    // ... 核销逻辑

    // 核销成功后发布签到事件
    _ = l.svcCtx.CreditEventPublisher.Publish(l.ctx, &publisher.CreditEventData{
        Type:       "checkin",
        ActivityID: ticket.ActivityID,
        UserID:     ticket.UserID,
    })

    return &pb.VerifyTicketResp{Success: true}, nil
}
```

#### 场景2: 取消报名

```go
// cancel_registration_logic.go
func (l *CancelRegistrationLogic) CancelRegistration(in *pb.CancelReq) (*pb.CancelResp, error) {
    // ... 取消逻辑

    // 判断是否为临期取消
    eventType := "cancel_early"
    if activity.StartTime.Sub(time.Now()) < 24*time.Hour {
        eventType = "cancel_late"
    }

    // 发布取消事件
    _ = l.svcCtx.CreditEventPublisher.Publish(l.ctx, &publisher.CreditEventData{
        Type:       eventType,
        ActivityID: in.ActivityID,
        UserID:     in.UserID,
    })

    return &pb.CancelResp{Success: true}, nil
}
```

#### 场景3: 活动结束处理（定时任务或 Webhook）

```go
// 活动结束后的定时任务
func processActivityEnd(ctx context.Context, activity *model.Activity, svcCtx *svc.ServiceContext) {
    // 1. 获取所有已报名但未签到的用户
    noShowUsers, _ := svcCtx.TicketModel.FindNoShowUsers(ctx, activity.ID)

    // 2. 批量发布爽约事件
    for _, userID := range noShowUsers {
        _ = svcCtx.CreditEventPublisher.Publish(ctx, &publisher.CreditEventData{
            Type:       "noshow",
            ActivityID: activity.ID,
            UserID:     userID,
        })
    }

    // 3. 如果签到率达标，给组织者加分
    if activity.CheckinRate >= 0.8 { // 假设80%签到率为达标
        _ = svcCtx.CreditEventPublisher.Publish(ctx, &publisher.CreditEventData{
            Type:       "host_success",
            ActivityID: activity.ID,
            UserID:     activity.CreatorID,
        })
    }
}
```

#### 场景4: 删除活动

```go
// delete_activity_logic.go
func (l *DeleteActivityLogic) DeleteActivity(in *pb.DeleteActivityReq) (*pb.DeleteActivityResp, error) {
    // ... 获取活动信息

    // 检查是否有人报名
    registrationCount, _ := l.svcCtx.TicketModel.CountByActivityID(l.ctx, in.ActivityID)

    // ... 执行删除

    // 如果有报名者，扣除组织者信用分
    if registrationCount > 0 {
        _ = l.svcCtx.CreditEventPublisher.Publish(l.ctx, &publisher.CreditEventData{
            Type:       "host_delete",
            ActivityID: in.ActivityID,
            UserID:     activity.CreatorID,
        })
    }

    return &pb.DeleteActivityResp{Success: true}, nil
}
```

---

## 5. 幂等性保证

### 5.1 消费端幂等（已实现）

User MQ 通过 **SourceID 唯一索引** 保证幂等：

```go
// SourceID 格式: {eventType}:{activityId}:{userId}
// 例如: "checkin:123456:789"
sourceID := fmt.Sprintf("%s:%d:%d", event.Type, event.ActivityID, event.UserID)
```

数据库表 `credit_logs` 有唯一索引 `uk_source_id`，重复插入会被拦截。

### 5.2 生产端建议

建议在发布端也做一些防护：

```go
// 方案1: 使用 Redis SetNX 防重（可选）
lockKey := fmt.Sprintf("credit:publish:lock:%s:%d:%d", eventType, activityID, userID)
if ok, _ := rdb.SetNX(ctx, lockKey, "1", 10*time.Minute).Result(); !ok {
    logx.Infof("[CreditEvent] 事件已发布，跳过: %s", lockKey)
    return nil
}

// 方案2: 依赖消费端幂等（推荐）
// 直接发布，消费端会通过 SourceID 去重
```

---

## 6. 错误处理

### 6.1 消费端错误处理（已实现）

| 错误类型 | 处理方式 |
|---------|---------|
| JSON 解析失败 | 丢弃消息，不重试 |
| 用户ID/活动ID 无效 | 丢弃消息，不重试 |
| 未知事件类型 | 丢弃消息，不重试 |
| 用户信用记录不存在 | 丢弃消息，不重试（用户可能未注册） |
| 唯一索引冲突（幂等） | 视为成功，不重试 |
| 数据库错误 | **返回错误，触发重试** |

### 6.2 生产端建议

```go
// 发布失败时记录日志，后续可通过日志补发
if err := publisher.Publish(ctx, event); err != nil {
    logx.Errorf("[CreditEvent] 发布失败，需人工补发: %+v, err=%v", event, err)
    // 可选：写入本地失败队列，定时重试
}
```

---

## 7. 监控与日志

### 7.1 关键日志格式

**发布成功**:
```
[CreditEvent] 发布成功: msgId=1234567890-0, type=checkin, userId=789, activityId=123456
```

**消费成功**:
```
[CreditChangeHandler] 处理成功: userId=789, type=checkin, delta=2, sourceId=checkin:123456:789
```

**幂等拦截**:
```
[CreditChangeHandler] 幂等拦截: sourceId=checkin:123456:789
```

### 7.2 监控指标（建议）

| 指标 | 说明 |
|------|------|
| `credit_event_publish_total` | 发布事件总数 |
| `credit_event_publish_error` | 发布失败数 |
| `credit_event_consume_total` | 消费事件总数 |
| `credit_event_consume_latency` | 消费延迟 |
| `credit_event_idempotent_hit` | 幂等拦截次数 |

---

## 8. 测试验证

### 8.1 手动发布测试消息

```bash
# 使用 redis-cli 发布测试消息
redis-cli XADD credit:events '*' type credit_change data '{"type":"checkin","activity_id":123456,"user_id":789,"timestamp":1706745600}'

# 查看 Stream 消息
redis-cli XRANGE credit:events - +

# 查看消费者组信息
redis-cli XINFO GROUPS credit:events

# 查看待处理消息
redis-cli XPENDING credit:events user-mq-group
```

### 8.2 验证信用分变更

```sql
-- 查看用户信用分
SELECT * FROM user_credits WHERE user_id = 789;

-- 查看信用变更记录
SELECT * FROM credit_logs WHERE user_id = 789 ORDER BY created_at DESC;
```

---

## 9. 待办事项

### 9.1 User 模块（已完成）

- [x] 定义 Stream Key 常量 (`common/constants/redis_key.go`)
- [x] 实现 CreditChangeHandler (`app/user/mq/internal/handler/credit_change_handler.go`)
- [x] 实现幂等处理（SourceID 唯一索引）
- [x] 实现缓存删除逻辑
- [x] 实现 Redis Stream 消费者 (`app/user/mq/internal/consumer/consumer.go`)
- [x] 实现 MQ 服务启动代码 (`app/user/mq/user_mq.go`)

### 9.2 Activity 模块（待实现）

- [ ] 封装 CreditEventPublisher
- [ ] 核销票券时发布 `checkin` 事件
- [ ] 取消报名时发布 `cancel_early` / `cancel_late` 事件
- [ ] 活动结束时发布 `noshow` 事件（批量）
- [ ] 活动圆满结束时发布 `host_success` 事件
- [ ] 删除活动时发布 `host_delete` 事件

---

## 10. 联系方式

如有问题，请联系：

- **User 模块负责人**: lijunqi
- **相关代码位置**:
  - 消费端: `app/user/mq/`
  - 信用分服务: `app/user/rpc/internal/logic/creditservice/`
  - 常量定义: `common/constants/credit.go`, `common/constants/redis_key.go`
